# 基础知识点

## 目录

- [声明](#声明)
- [变量](#变量)
  - [类型零值](#类型零值)
  - [简单声明](#简单声明)
  - [new函数](#new函数)
  - [变量的生命周期](#变量的生命周期)
- [内存逃逸](#内存逃逸)

Go语言中类似if和switch的关键字有25个；

关键字不能用于自定义名字，只能在特定语法结构中使用。

```go 
break      default       func     interface   select

case       defer         go       map         struct

chan       else          goto     package     switch

const      fallthrough   if       range       type

continue   for           import   return      var
```


此外，还有大约30多个预定义的名字，比如int和true等，主要对应内建的常量、类型和函数。

内建常量:&#x20;

```go 
true false iota nil
```


内建类型:

```go 
int int8 int16 int32 int64

uint uint8 uint16 uint32 uint64 uintptr

float32 float64 complex128 complex64

bool byte rune string error
```


内建函数:

```go 
make len cap new append copy close delete

complex real imag

panic recover
```


### 声明

Go语言主要有四种类型的声明语句：var、const、type和func，分别对应变量、常量、类型和函数实体对象的声明。

### 变量

```go 
var 变量名字 类型 = 表达式
```


其中“*类型*”或“*= 表达式*”两个部分可以省略其中的一个。

如果省略的是类型信息，那么将根据初始化表达式来推导变量的类型信息。

如果初始化表达式被省略，那么将用零值初始化该变量。

#### 类型零值

1. 数值类型变量对应的零值是0，
2. 布尔类型变量对应的零值是false，
3. 字符串类型对应的零值是空字符串，
4. 接口或引用类型（包括slice、指针、map、chan和函数）变量对应的零值是nil。
5. 数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。

> 零值初始化机制可以确保每个声明的变量总是有一个良好定义的值，因此在Go语言中不存在未初始化的变量。

#### 简单声明

名字 := 表达式

> 变量的类型根据表达式来自动推导。

简短变量声明左边的变量可能并不是全部都是刚刚声明的。

如果有一些已经在相同的词法域声明过了，那么简短变量声明语句对这些已经声明过的变量就只有赋值行为了。

#### new函数

> 表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为`*T`。

#### 变量的生命周期

包：它们的生命周期和整个程序的运行周期是一致的

局部变量： 生命周期是动态的每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。

函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建。

### 内存逃逸

```go 
var global *int

func f() {
    var x int
    // 这里我们本来是要分配到栈上的 ， 但是因为global的引用，所以这里我们需要分配到堆上。 
    x = 1
    global = &x
}

func g() {
    y := new(int)
    *y = 1
}
```


f函数里的x变量必须在堆上分配，因为它在函数退出后依然可以通过包一级的global变量找到，虽然它是在函数内部定义的；

用Go语言的术语说，这个x局部变量从函数f中逃逸了。

相反，当g函数返回时，变量`*y`将是不可达的，也就是说可以马上被回收的。

> 逃逸的变量需要额外分配内存，同时对性能的优化可能会产生细微的影响
