# mysql  规范

## 目录

- [数据库命名](#数据库命名)
- [表命名](#表命名)
- [字段命名](#字段命名)
- [索引命名](#索引命名)
- [视图](#视图)
- [表设计规范](#表设计规范)
- [索引设计规范](#索引设计规范)

[ 公司用的 MySQL 团队开发规范，太详细了，建议收藏！  https://mp.weixin.qq.com/s/vCF8zTB8acZj-k8jrlsM8Q](https://mp.weixin.qq.com/s/vCF8zTB8acZj-k8jrlsM8Q " 公司用的 MySQL 团队开发规范，太详细了，建议收藏！  https://mp.weixin.qq.com/s/vCF8zTB8acZj-k8jrlsM8Q")

# 数据库命名

- 数据库命名一般为项目名称+代表库含义的简写，比如IM项目的工作流数据库，可以是 im\_flow。
- 命名应使用小写

# 表命名

- 常规表表名以t\_开头，t代表table的意思，命名规则即 t + 模块（包含模块含义的简写）+ 表（包含表含义的简写），比如用户模块的教育信息表：t\_user\_eduinfo。
- 临时表（RD、QA或DBA同学用于数据临时处理的表），命名规则：temp前缀+模块+表+日期后缀：temp\_user\_eduinfo\_20210719。
- 备份表（用于保存和归档历史数据或者作为灾备恢复的数据）命名规则，bak前缀+模块+表+日期后缀：bak\_user\_eduinfo\_20210719。
- 同一个模块的表尽可能使用相同的前缀，表名称尽可能表达含义。
- 多个单词以下划线 \_ 分隔。
- 常规表表名尽量不超过30个字符，temp表和bak表视情况而定，也尽量简短为宜，命名应使用小写。

# 字段命名

- 字段命名需要表示其实际含义的英文单词或简写，单词之间用下划线 \_ 进行连接，如 service\_ip、service\_port。
- 各表之间相同意义的字段必须同名，比如a表和b表都有创建时间，应该统一为create\_time，不一致会很混乱。
- 多个单词以下划线 \_ 分隔
- 字段名尽量不超过30个字符，命名应该使用小写

# 索引命名

- 唯一[索引](http://mp.weixin.qq.com/s?__biz=MzI0MDQ4MTM5NQ==\&mid=2247487492\&idx=2\&sn=319be0c2fdd5a89c9464c9f2775ed551\&chksm=e91b7518de6cfc0ec75c032b1bdb9b6fe90c505d543c2b45c6d021accd72a8127e6f6b54ec1b\&scene=21#wechat_redirect "索引")使用uni + 字段名 来命名：`create unique index uni_uid on t_user_basic(uid)` 。
- 非唯一索引使用idx + 字段名 来命名：`create index idx_uname_mobile on t_user_basic(uname,mobile)` 。
- 多个单词以下划线 \_ 分隔。
- 索引名尽量不超过50个字符，命名应该使用小写，组合索引的字段不宜太多，不然也不利于查询效率的提升。
- 多单词组成的列名，取尽可能代表意义的缩写，如 test\_contact表member\_id和friend\_id上的组合索引：idx\_mid\_fid。
- 理解组合索引最左前缀原则，避免重复建设索引，如果建立了(a,b,c)，相当于建立了(a), (a,b), (a,b,c)。

# 视图

- 视图名以v开头，表示view，完整结构是v+视图内容含义缩写。
- 如果视图只来源单个表，则为v+表名。如果视图由几个表关联产生就用v+下划线（ \_）连接几个表名，视图名尽量不超过30个字符。如超过30个字符则取简写。
- 如无特殊需要，严禁开发人员创建视图。
- 命名应使用小写。

# 表设计规范

- 不允许使用外键对表之间进行关联： 不同应用间所对应的数据库表之间的关联应尽可能减少，不允许使用外键对表之间进行关联，确保组件对应的表之间的独立性，为系统或表结构的重构提供可能性。目前业内的做法一般 由程序控制参照完整性。
- 需要join的字段(连接键)，数据类型必须保持绝对一致，避免隐式转换。比如关联的字段都是int类型。
- TEXT字段作为大体量文本存储，必须放在独立的表中 , 用PK与主表关联。如无特殊需要，禁止使用TEXT、BLOB字段。
- 设计应至少满足第三范式,尽量减少数据冗余。一些特殊场景允许反范式化设计，但在项目评审时需要对冗余字段的设计给出解释。
- 需要定期删除(或者转移)过期数据的表，通过分表解决，我们的做法是按照2/8法则将操作频率较低的历史数据迁移到历史表中，按照时间或者则曾Id做切割点。
- 单表字段数不要太多，建议最多不要大于50个。过度的宽表对性能也是很大的影响。
- 表必须要有PK，主键的优势是唯一标识、有效引用、高效检索，所以一般情况下尽量有主键字段。
- 一个字段只表示一个含义。
- 表不应该有重复列。
- 禁止使用复杂数据类型(数组,自定义等)，Json类型的使用视情况而定。
- MySQL在处理大表时，性能就开始明显降低，所以建议单表物理大小限制在16GB，表中数据行数控制在2000W内。
- 如果数据量或数据增长在前期规划时就较大，那么在设计评审时就应加入分表策略，数据拆分的做法：垂直拆分、水平拆分；
- 无特殊需求，严禁使用分区表

# 索引设计规范

- 索引区分度

  索引必须创建在索引选择性（区分度）较高的列上，选择性的计算方式为:  `selecttivity = count(distinct c_name)/count(*) ;`如果区分度结果小于0.2，则不建议在此列上创建索引，否则大概率会拖慢SQL执行
- 遵循最左前缀
  - 对于确定需要组成组合索引的多个字段，设计时建议将选择性高的字段靠前放。使用时，组合索引的首字段，必须在where条件中，且需要按照最左前缀规则去匹配。
- Text类型字段如果需要创建索引，必须使用前缀索引
- 单张表的索引数量理论上应控制在5个以内。经常有大批量插入、更新操作表，应尽量少建索引，索引建立的原则理论上是多读少写的场景。
- ORDER BY，GROUP BY，DISTINCT的字段需要添加在索引的后面，形成覆盖索引
- 正确理解和计算索引字段的区分度，文中有计算规则，区分度高的索引，可以快速得定位数据，区分度太低，无法有效的利用索引，可能需要扫描大量数据页，和不使用索引没什么差别。
- 正确理解和计算前缀索引的字段长度，文中有判断规则，合适的长度要保证高的区分度和最恰当的索引存储容量，只有达到最佳状态，才是保证高效率的索引。
- 联合索引注意最左匹配原则：必须按照从左到右的顺序匹配，MySQL会一直向右匹配索引直到遇到范围查询(>、<、between、like)然后停止匹配。

  如：depno=1 and empname>'' and job=1 如果建立(depno,empname,job)顺序的索引，job是用不到索引的。
- 应需而取策略，查询记录的时候，不要一上来就使用 \*，只取需要的数据，可能的话尽量只利用索引覆盖，可以减少回表操作，提升效率。
- 正确判断是否使用联合索引（上面联合索引的使用那一小节有说明判断规则），也可以进一步分析到索引下推（IPC），减少回表操作，提升效率。
- 避免索引失效的原则：禁止对索引字段使用函数、运算符操作，会使索引失效。这是实际上就是需要保证索引所对应字段的”干净度“。
- 模糊查询'%value%'会使索引无效，变为全表扫描，因为无法判断扫描的区间，但是'value%'是可以有效利用索引。
- 索引覆盖排序字段，这样可以减少排序步骤，提升查询效率
- 尽量的扩展索引，非必要不新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。

举例子：比如一个品牌表，建立的的索引如下，一个主键索引，一个唯一索引

PRIMARY KEY (`id`),UNIQUE KEY `uni_brand_define` (`app_id`,`define_id`)

当你同事业务代码中的检索语句如下的时候，应该立即警告了，即没有覆盖索引，也没按照最左前缀原则：

select brand\_id,brand\_name from  ds\_brand\_system where status=?  and define\_id=?  and app\_id=?

建议改成如下：

select brand\_id,brand\_name from  ds\_brand\_system where app\_id=? and define\_id=?  and  status=?
