{"./":{"url":"./","title":"首页","keywords":"","body":"我的知识库 [x] honkit [ ] go [ ] node.js [ ] python [ ] vue ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 09:40:43 "},"doc/honkit/安装.html":{"url":"doc/honkit/安装.html","title":"honkit安装","keywords":"","body":"honkit安装 下载node.js 地址 下载honkit npm install honkit // 初始化 会自动创建summary(文件左侧菜单结构), readme(首页文件)文件 //可以根据summary 自动创建文件夹和文件 npm honkit init // 生成_book文件 npx honkit build // 预览网站 npx honkit serve // 打包成pdf npx honkit pdf 简化命令 在package.json 文件中增加 { \"scripts\": { \"build\": \"npx honkit build\", \"serve\": \"npx honkit serve\", \"book\": \"npx honkit init\", \"pdf\": \"npx honkit pdf\" } } ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-03-27 14:32:03 "},"doc/honkit/插件.html":{"url":"doc/honkit/插件.html","title":"honkit插件","keywords":"","body":"honkit插件 配置插件 在book.json中配置插件 plugins中配置插件名，pluginsConfig中配置插件信息 plugins中插件名前加-，表示取消插件(默认配置了5个插件) 安装插件 npm install gitbook-plugin-[插件名] 插件介绍 名称 介绍 highlight 语法高亮插件，代码高亮功能 search 搜索插件，不支持中文搜索 sharing 分享插件，右上角分享功能 font-settings 字体设置（最上方的\"A\"符号） livereload 热加载插件，为 GitBook 编辑进行实时重新预览加载 其他插件 expandable-chapters-small 子目录折叠 chapter-fold 子目录折叠，和expandable-chapters-small一起使用 get-pdf 下载pdf按钮 base 文件目录，prefix 文件名,label 下载按钮名称 \"get-pdf\":{ \"base\": \"/summary/assets\", \"prefix\": \"book\", \"label\": \"下载 PDF\" } code 代码块复制按钮+代码行号 \"code\":{ \"copyButtons\": true } search-pro 搜索栏 tbfed-pagefooter 页脚信息 \"tbfed-pagefooter\": { \"copyright\":\"©2025 xxxxx\", \"modify_label\": \"该文档修订时间：\", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\" } flexible-alerts 对提示框的增强。NOTE,TIP,WARNING,DANGER ``` [!NOTE] 这是一个提示框。 [!WARNING] 这是一个警告框。 [!TIP] 这是一个提示框。 [!DANGER] 这是一个危险框。 * anchor-navigation-ex 添加 Toc 到侧边悬浮导航以及回到顶部按钮。需要注意以下两点：本插件只会提取 h1,h2,h3 标签作为悬浮导航 \"pluginsConfig\": { \"anchor-navigation-ex\": { \"showLevel\": false, \"showGoTop\": true, \"isRewritePageTitle\": true, \"isShowTocTitleIcon\": true, \"tocLevel1Icon\": \"fa fa-hand-o-right\", \"tocLevel2Icon\": \"fa fa-hand-o-right\", \"tocLevel3Icon\": \"fa fa-hand-o-right\" } } * github@2.0.0 添加 github 图标 { \"plugins\": [ \"github\" ], \"pluginsConfig\": { \"github\": { \"url\": \"https://github.com/your/repo\" } } } * sectionx 页面分块 { \"plugins\": [ \"sectionx\" ], \"pluginsConfig\": { \"sectionx\": { \"tag\": \"b\" } } } * 3-ba 百度统计 百度统计插件 { \"plugins\": [\"3-ba\"], \"pluginsConfig\": { \"3-ba\": { \"token\": \"xxxxxxxx\" } } } ``` 启动以后，可以在浏览器中用 F12 看一下源代码是否包含如下片段：https://hm.baidu.com/hm.js ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-03-27 15:14:14 "},"doc/honkit/插件使用.html":{"url":"doc/honkit/插件使用.html","title":"honkit插件使用","keywords":"","body":"插件使用 code 代码复制 import { useStore } from 'vuex' import { computed } from 'vue' const store = useStore() flexible-alerts 对提示框的增强 [!NOTE] 这是一个提示框。 Info flat [!WARNING] 这是一个警告框。 Info flat [!TIP] 这是一个提示框。 Info flat [!DANGER] 这是一个危险框。 ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-03-27 15:29:05 "},"doc/后端/mysql/mysql.html":{"url":"doc/后端/mysql/mysql.html","title":"mysql","keywords":"","body":"mysql 目录 基础 sql分类 字段冗余性设计 其他 其他 基础 sql分类 分类 说明 DDl 数据库定义语言，用来定义数据库对象（数据库， 表，字段） DML 数据库操作语言， 增删改 DQL 数据库查询语言 DCL 数据控制语言， 用来创建数据库用户，权限 字段冗余性设计 优点： 比如name就可以冗余在 表里， 这样当只需要name的时候可以避免多次的 去查询其他表。 缺点: 数据时效性没有这么强。 ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-11 11:13:06 "},"doc/后端/mysql/mysql 初步安装/mysql 初步安装.html":{"url":"doc/后端/mysql/mysql 初步安装/mysql 初步安装.html","title":"mysql 初步安装","keywords":"","body":"mysql 初步安装 目录 windows初步安装 docker 安装mysql 社区版本 windows初步安装 https://dev.mysql.com/downloads/file/?id=516927 选择安装的服务 安装相应依赖 docker 安装mysql # 创建数据卷 docker volume create mysql docker run -itd --name mysql -p 3306:3306 \\ -e MYSQL_ROOT_PASSWORD=123456 \\ -v mysql:/var/lib/mysql \\ mysql:latest # 创建用户 create user 'sa'@'%' identified by '123456'; # 授予所有数据库表的权限给用户 grant all on *.* to 'sa'@'%'; ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 10:02:41 "},"doc/后端/mysql/DML 数据库操作语言/DML 数据库操作语言.html":{"url":"doc/后端/mysql/DML 数据库操作语言/DML 数据库操作语言.html","title":"DML 数据库操作语言","keywords":"","body":"DML 数据库操作语言 目录 其他复杂的操作语句 select insert into update delete # 添加数据 insert into 表名(字段名1,字段名2,字段名3) values(val1,val2,val3) insert into 表名 values(val1,val2,val3) # 批量新增 insert into 表名(字段名1,字段名2,字段名3) values(val1,val2,val3),(val1,val2,val3) insert into 表名 values(val1,val2,val3),(val1,val2,val3),(val1,val2,val3) # 更新 update 表名 set 字段名1=val1, 字段名2=val2 [where 条件]; # 删除 delete from 表名 [where 条件]; 其他复杂的操作语句 insert select : 根据查询新增 INSERT INTO table2 (column1, column2, column3, ...) SELECT column1, column2, column3, ... FROM table1 WHERE condition; udpate : 多表更新 update table1,table2 set table1.col1 = table2.col1, table1.col2 = table2.col2 where table1.id=table2.id ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 10:02:41 "},"doc/后端/mysql/DDL 数据定义语言/DDL 数据定义语言.html":{"url":"doc/后端/mysql/DDL 数据定义语言/DDL 数据定义语言.html","title":"DDL 数据定义语言","keywords":"","body":"DDL 数据定义语言 目录 数据库 表 示例 创建表 示例 数据库 // 创建数据库 create database [if not exists] 数据库名; // 删除数据库 drop database [if exists] 数据库名; // 使用数据库 use 数据库名; 表 # 创建表 create table [if not exists ] 表名( 字段1 类型 [其他约束 primary key | auto_increment | not null | default '' ] [comment '主键'], 字段2 类型 [comment '名称'], 字段3 类型 comment '备注' )[comment '测试表']; # 添加字段 alter table 表名 add 字段名 类型 [comment '注释'][约束]; # 修改数据类型 alter table 表名 modify 字段名 新数据类型; # 修改字段名和字段类型 alter table 表名 change 旧字段名 新字段名 类型 [comment '注释'][约束]; # 删除字段 alter table 表名 drop 字段名; # 修改表名 alter table 旧表名 rename to 新表名 # 删除表 drop table [if exists] 表名; # 会把id等一些信息重置 truncate table 表名; create database : 创建新数据库 alter database : 修改数据库 craete table : 创建表 alter table \\ : 改变数据库 drop table ： 删除表 create index : 创建索引 drop index : 删除索引 示例 创建表 create table if not exists my_test( id bigint primary key auto_increment comment '主键', name varchar(50) not null default '' comment '名称', remark text not null comment '备注' )comment '测试表' # 创建员工表 create table if not exists emp ( id int primary key auto_increment not null comment '主键id', work_no varchar(10) not null default '' comment '工号', name varchar(10) not null default '' comment '员工姓名', gender char(1) not null default '' comment '性别', age tinyint unsigned not null default 1 comment '年龄', id_card char(18) not null default '' comment '身份证', entry_date date comment '入职时间' ) comment '员工表' ## 修改表字段 alter table tableName change ## 新增索引 create index table_colu_name on tableName (column1,column2) 示例 select from 表名 Where 条件 Group By 字段 Having 条件 Order By 字段 Limit skipNum ,takeNum ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 10:02:41 "},"doc/后端/mysql/DQL 数据库查询语言/DQL 数据库查询语言.html":{"url":"doc/后端/mysql/DQL 数据库查询语言/DQL 数据库查询语言.html","title":"DQL 数据库查询语言","keywords":"","body":"DQL 数据库查询语言 目录 查询 多表查询 内链接 左链接 右链接 联合查询 union ,union all 子查询 执行顺序 其他 聚合函数 排序 查询 # 普通查询 select 字段列表 from 表名列表 where 条件列表 group by 分组字段列表 having 分组后条件列表 order by 排序字段列表 limit 分页参数 # 普通查询 select from 表名 Where 条件 Group By 字段 Having 条件 Order By 字段 Limit skipNum ,takeNum # 聚合查询 select 聚合函数(字段列表) from 表名; 多表查询 内链接 左链接 右链接 内链接 select 字段列表 from 表1 [inner] join 表2 on 链接条件 左链接 select 字段列表 from 表1 left join 表2 on 链接条件 右链接 select 字段列表 from 表1 right join 表2 on 链接条件 联合查询 union ,union all 合并两个查询相同的 结果集， union 不会返回重复值， union all可以返回重复值。 select 字段列表 from 表1 union [all] select 字段列表 from 表2 子查询 sql语句中嵌套的select 语句，称为嵌套查询，又称子查询 select * from t1 where column1=(select column1 from t2); select * from t1 where (column1,column2)=(select column1,column1 from t2); 执行顺序 其他 聚合函数 函数 功能 count 统计数量 max 最大值 min 最小值 avg 平均值 sum 求和 排序 asc： 升序（默认） desc: 降序 ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 10:02:41 "},"doc/后端/mysql/DCL 数据控制语言/DCL 数据控制语言.html":{"url":"doc/后端/mysql/DCL 数据控制语言/DCL 数据控制语言.html","title":"DCL 数据控制语言","keywords":"","body":"DCL 数据控制语言 目录 管理用户 权限 权限 管理数据库 用户，访问权限。 管理用户 # 查询用户 use mysql ; select * from user; # 创建用户 create user '用户名'@'主机名' identified by '密码'; # 任意主机 create user '用户名'@'%' identified by '密码'; # 修改用户 alter user '用户名'@'主机名' identified with mysql_native_password by '新密码'; # 删除用户 drop user '用户名'@'主机名'; 权限 # 查询权限 show grants for '用户名'@'主机名'; # 授予权限 grant 权限列表 on 数据库名.表名 to '用户名'@'主机名'; # 授予所有数据库表的权限给用户 grant all on *.* to '用户名'@'主机名'; # 撤销权限 revoke 权限列表 on 数据库名.表名 from '用户名'@'主机名'; 权限 all，all privileges 所有权限 selcet 查询 insert 插入数据 update 更新数据 delete 删除数据 alter 修改表 drop 删除数据库/表/视图 create 创建数据库/表 ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 10:02:41 "},"doc/后端/mysql/函数/函数.html":{"url":"doc/后端/mysql/函数/函数.html","title":"函数","keywords":"","body":"函数 目录 基础函数 case when ifnull concat 函数是指一段可以直接被另一段程序调用的程序或者代码 基础函数 分类 函数 解释 字符串 CONCAT(S1,S2,...Sn) 字符串拼接，将S1，S2,Sn拼接成一个字符串 LOWER($) 将字符串str全部转为小写 UPPER(str) 将字符串str全部转为大写 LPAD(str,n,pad) 左填充，用字符串pad对str的左边进行填充，达到n个字符串长度 RPAD(str,n,pad) 右填充，用字符串pad对str的右边进行填充，达到n个字符串长度 TRIM(str) 去掉字符串头部和尾部的空格 SUBSTRING(str,start,len) 返回从字符串str从start位置起的len个长度的字符串 数值函数 CEIL(x) 向上取整 FLOOR(X) 向下取整 MOD(x,y) 返回x/y的模 RAND(x,y) 返回0~1内的随机数 ROUND(x,y) 求参数x的四舍五入的值，保留y位小数 日期函数 curdate() 返回当前日期 curtime() 返回当前时间 now() 返回当前日期和时间 year(date) 获取指定的年份 month(date) 获取指定的月份 day(date) 获取指定的日份 date_add(date,interval type) 返回一个日期/时间值加上一个时间间隔expr后的时间值date_add(now(),interval 70 year) datediff(date1,date2) 返回起始时间date1和结束时间date2之间的天数 date_format() 流程函数 if(value ,t ,f ) 如果val为true ,则返回t，否则返回f ifnull(val1,val2) 如果val不为空，返回val1,否则返回val2 case [expr] when [val1] then [rest] else [default] end 如果expr的值等于val1，。。返回返回default默认值 case when case when 根据条件返回指定内容 case where [条件] then 结果 where [条件] then 结果 else 结果 end ifnull 转换空值，下面是把 空转成无。 ifnull(null,\"无\") concat 链接字符串函数 ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 10:02:41 "},"doc/后端/mysql/mysql 数据类型/mysql 数据类型.html":{"url":"doc/后端/mysql/mysql 数据类型/mysql 数据类型.html","title":"mysql 数据类型","keywords":"","body":"mysql 数据类型 分类 类型 大小 有符号（sinend）范围 无符号（unsinend）范围 描述 数值类型 tinyint 1 byte (-128,127) (0,255) 小整数值 smallint 2 bytes (-32768,32767) (0,65535) 大整数值 mediumint 3 bytes (-8388608,8388607) (0,16777215) 大整数值 int 或integer 4 bytes (-2147483648,2147483647) (0,4294967295) 大整数值 bigint 8 bytes (-2^63,2^63-1) (0,2^64-1) 极大整数值 float 4 bytes 单精度浮点值 double 8 bytes 双精度浮点值 decimal 小数值（精确定点数） 字符串类型 char 0-255 bytes 定长字符串 varchar 0-65535 bytes 变长字符串 tinyblob 0-255 bytes 不超过255个字符的二进制数据 tinytext 0-255 bytes 短文本字符串 blob 0-65535 bytes 二进制长文本数据 text 0-65535 bytes 长文本数据 mediumblob 0-16777215 bytes 二进制中等长度文本数据 mediumtext 0-16777215 bytes 中等长度文本数据 longblob 0-4294967295 bytes 二进制极大文本数据 longtext 0-4294967295 bytes 极大文本数据 日期类型 date 3 1000-01-01 至9999-12-31 YYYY-MM-DD 日期值 time 3 -838:59:59 至 838：59：59 HH：MM：SS 时间值或持续时间 year 1 1901 至 2155 YYYY 年份值 datetime 8 1000-01-01 00:00:00 至 9999-12-31 23：59：59 YYYY-MM-DD HH:MM:SS 混合日期和时间值 timestamp 4 1970-01-01 00：00：00 至 2038-01-19 03：14：07 YYYY-MM-DD HH:MM:SS 混合日期和时间值，时间戳 ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 10:02:41 "},"doc/后端/mysql/约束/约束.html":{"url":"doc/后端/mysql/约束/约束.html","title":"约束","keywords":"","body":"约束 约束 描述 关键之 非空约束 限制该字段不能为空 not null 唯一约束 保证该字段所有数据唯一 ，不重复 unique 主键约束 主键是一行数据的唯一标识，要求非空并且唯一 primary key 默认约束 保存数据如果没有指定该数据，则采用默认值 default 外键约束 两张表建立链接的 foreign key ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 10:02:41 "},"doc/后端/mysql/事务/事务.html":{"url":"doc/后端/mysql/事务/事务.html","title":"事务","keywords":"","body":"事务 目录 简介 事务四大特性 并发事务问题 简介 > # 开启事务 start transaction 或者 begin; # 提交事务 commit; # 回滚事务 rollback; 事务四大特性 原子性： 事务是不可分割的最小单元，要么全部成功，要么全部失败 一致性： 事务完成时， 所有数据必须保持一致状态 隔离性：不受外部并发操作影响 持久性：事务一旦提交或者回滚，数据改变就是永久的 并发事务问题 脏读：一个事务读到另外一个事务还没有提交的数据 不可重复读： 一个事务先后读取同一条记录，但是两次读取的数据不同 幻读：一个事务按照条件查询数据时，么有对应的数据行， 但是在插入的时候，又发现这行数据已经存在， 好像出现了‘幻读’ ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 10:02:41 "},"doc/后端/mysql/存储引擎/存储引擎.html":{"url":"doc/后端/mysql/存储引擎/存储引擎.html","title":"存储引擎","keywords":"","body":"存储引擎 目录 简介 innoDB myisam memory 对照 简介 # 查询当前数据库支持的存储引擎 show endines; # 创建表，指定引擎存储 create table 表名( ... )engine = innodb innoDB 默认引擎，兼顾可靠性和高性能的通用存储引擎 特点： dml操作遵循acid模型， 支持事务，支持行级锁，支持外键 myisam myIsam是mysql早期的默认引擎 特点： 不支持事务，不支持外键，支持表锁，不支持行锁，访问速度快 memory 可以作为临时表或缓存使用 特点：内存存放，hash索引（默认） 对照 特点 innodb myisam memory 存储限制 64TB 有 有 事务安全 支持 - - 锁机制 行锁 表锁 表锁 b+tree索引 支持 支持 支持 hash 索引 - - 支持 全文索引 支持 支持 - 空间使用 高 低 n/a 内存使用 高 低 中等 批量插入速度 低 高 高 支持外键 支持 - - 使用场景 一般应用 应用以读，插入为主，很少更新（nosql替代） 缓存，临时表（redis替代） ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 10:02:41 "},"doc/后端/mysql/索引/索引.html":{"url":"doc/后端/mysql/索引/索引.html","title":"索引","keywords":"","body":"索引 目录 简介 索引结构 二叉树 b-tree （多路平衡查询树） b+tree (msyql 默认) hash 索引分类 索引使用 优缺点 优势： 缺点： 索引设计原则 简介 索引结构 索引分类 索引语法 sql性能分析 索引使用 索引设计原则 索引结构 二叉树 b-tree （多路平衡查询树） b+tree (msyql 默认) 层级少， 效率高 hash 索引分类 分类 含义 特点 聚焦索引 将数据存储与索引放一块，索引结构的叶子节点保存了行数据 必须有，并且只有一个 二级索引 将数据存储与索引分开存储，索引结构的叶子节点关联的是对应的主键 可以存多个 索引使用 # 创建索引 create [unique| FULLTEXT ] index 索引名称 on 表名(表字段,....); # 创建前缀索引 create index idx_xxx_xxx on 表名(表字段(长度)) # 查看索引 show index from 表名; # 删除索引 drop index 索引名称 on 表名; 示例 # 查看所有 show index from emp; # 创建普通索引 create index idx_emp_name on emp(name); # 创建唯一索引 create unique index idx_emp_card on emp(id_card); # 创建联合索引 create index idx_emp_name_age_gender on emp(name,age,gender); 优缺点 优势： 提高索引检索效率 ，降低数据库io成本 通过对索引进行排序，降低排序的成本，降低cpu的消耗 缺点： 索引列占用空间 降低了增删改的效率 索引设计原则 针对于数据量较大，且查询比较频繁的表建立索引。 针对于常作为查询条件 (where)、排序 (order by)、分组 (group by) 操作的字段建立索引。 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增制改的效率 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。 ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 10:02:41 "},"doc/后端/mysql/sql优化/sql优化.html":{"url":"doc/后端/mysql/sql优化/sql优化.html","title":"sql优化","keywords":"","body":"sql优化 目录 查看数据库执行频率 慢查询日志 性能分析 profiling explain执行计划 索引失效场景 注意 分页查询limit语句 查看数据库执行频率 show global status like 'com_______'; 慢查询日志 慢查询日志记录了所有执行时间超过指定参数（long_query_time ,单位秒，默认10秒）的所有sql语句的日志 mysql 慢查询 日志默认是没有开启， 需要在mysql 的配置文件（/etc/my.cnf） # 开启mysql 慢日志查询 show_query_log=1 # 设置慢日志时间 log_query_time=2 配置完毕后， 重新启动mysql服务器，查看慢日志：/var/lib/mysql/localhost-show.log 性能分析 profiling # 查看是否支持 select @@have_profiling; # mysql profiling默认关闭 # 查看是否开启profiling select @@profiling; # 开启 set profiling=1; # 查看每一条sql耗时的基本情况 show profiles; # 查看指定query_id的sql语句各个阶段的耗时情况 show profile [cpu] for query query_id; explain执行计划 查看执行计划 直接在sql命令前加上explain 或者desc 命令 explain select * from 表 where 条件 索引失效场景 最左前缀法则： 如果索引是联合索引，则要遵循最左前缀法则从最左列开始，并且不跳过索引中的列，如果跳跃某一列，索引将部分失效。 不要在索引列上进行运算操作 字符串不加单引号 会导致索引失效 头部模糊查询会导致索引失效 or 链接条件，一侧有索引一侧无索引，会导致索引失效 注意 下面这个该怎样进行优化 select id ,username,pwd from user where username='test'; 优化方案： 增加username索引： 但是会有回表查询 增加username ,pwd 联合索引： 这样不会回表查询 分页查询limit语句 列表第一个重点： 排序 有了排序后 ， 我们上一页和下一也就可以用到排序的字段来进行条件判断并分页 加入组合索引 更改分页逻辑 ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 10:02:41 "},"doc/后端/mysql/mysql  规范/mysql  规范.html":{"url":"doc/后端/mysql/mysql  规范/mysql  规范.html","title":"mysql  规范","keywords":"","body":"mysql 规范 目录 数据库命名 表命名 字段命名 索引命名 视图 表设计规范 索引设计规范 公司用的 MySQL 团队开发规范，太详细了，建议收藏！ https://mp.weixin.qq.com/s/vCF8zTB8acZj-k8jrlsM8Q 数据库命名 数据库命名一般为项目名称+代表库含义的简写，比如IM项目的工作流数据库，可以是 im_flow。 命名应使用小写 表命名 常规表表名以t_开头，t代表table的意思，命名规则即 t + 模块（包含模块含义的简写）+ 表（包含表含义的简写），比如用户模块的教育信息表：t_user_eduinfo。 临时表（RD、QA或DBA同学用于数据临时处理的表），命名规则：temp前缀+模块+表+日期后缀：temp_user_eduinfo_20210719。 备份表（用于保存和归档历史数据或者作为灾备恢复的数据）命名规则，bak前缀+模块+表+日期后缀：bak_user_eduinfo_20210719。 同一个模块的表尽可能使用相同的前缀，表名称尽可能表达含义。 多个单词以下划线 _ 分隔。 常规表表名尽量不超过30个字符，temp表和bak表视情况而定，也尽量简短为宜，命名应使用小写。 字段命名 字段命名需要表示其实际含义的英文单词或简写，单词之间用下划线 _ 进行连接，如 service_ip、service_port。 各表之间相同意义的字段必须同名，比如a表和b表都有创建时间，应该统一为create_time，不一致会很混乱。 多个单词以下划线 _ 分隔 字段名尽量不超过30个字符，命名应该使用小写 索引命名 唯一索引使用uni + 字段名 来命名：create unique index uni_uid on t_user_basic(uid) 。 非唯一索引使用idx + 字段名 来命名：create index idx_uname_mobile on t_user_basic(uname,mobile) 。 多个单词以下划线 _ 分隔。 索引名尽量不超过50个字符，命名应该使用小写，组合索引的字段不宜太多，不然也不利于查询效率的提升。 多单词组成的列名，取尽可能代表意义的缩写，如 test_contact表member_id和friend_id上的组合索引：idx_mid_fid。 理解组合索引最左前缀原则，避免重复建设索引，如果建立了(a,b,c)，相当于建立了(a), (a,b), (a,b,c)。 视图 视图名以v开头，表示view，完整结构是v+视图内容含义缩写。 如果视图只来源单个表，则为v+表名。如果视图由几个表关联产生就用v+下划线（ _）连接几个表名，视图名尽量不超过30个字符。如超过30个字符则取简写。 如无特殊需要，严禁开发人员创建视图。 命名应使用小写。 表设计规范 不允许使用外键对表之间进行关联： 不同应用间所对应的数据库表之间的关联应尽可能减少，不允许使用外键对表之间进行关联，确保组件对应的表之间的独立性，为系统或表结构的重构提供可能性。目前业内的做法一般 由程序控制参照完整性。 需要join的字段(连接键)，数据类型必须保持绝对一致，避免隐式转换。比如关联的字段都是int类型。 TEXT字段作为大体量文本存储，必须放在独立的表中 , 用PK与主表关联。如无特殊需要，禁止使用TEXT、BLOB字段。 设计应至少满足第三范式,尽量减少数据冗余。一些特殊场景允许反范式化设计，但在项目评审时需要对冗余字段的设计给出解释。 需要定期删除(或者转移)过期数据的表，通过分表解决，我们的做法是按照2/8法则将操作频率较低的历史数据迁移到历史表中，按照时间或者则曾Id做切割点。 单表字段数不要太多，建议最多不要大于50个。过度的宽表对性能也是很大的影响。 表必须要有PK，主键的优势是唯一标识、有效引用、高效检索，所以一般情况下尽量有主键字段。 一个字段只表示一个含义。 表不应该有重复列。 禁止使用复杂数据类型(数组,自定义等)，Json类型的使用视情况而定。 MySQL在处理大表时，性能就开始明显降低，所以建议单表物理大小限制在16GB，表中数据行数控制在2000W内。 如果数据量或数据增长在前期规划时就较大，那么在设计评审时就应加入分表策略，数据拆分的做法：垂直拆分、水平拆分； 无特殊需求，严禁使用分区表 索引设计规范 索引区分度 索引必须创建在索引选择性（区分度）较高的列上，选择性的计算方式为: selecttivity = count(distinct c_name)/count(*) ;如果区分度结果小于0.2，则不建议在此列上创建索引，否则大概率会拖慢SQL执行 遵循最左前缀 对于确定需要组成组合索引的多个字段，设计时建议将选择性高的字段靠前放。使用时，组合索引的首字段，必须在where条件中，且需要按照最左前缀规则去匹配。 Text类型字段如果需要创建索引，必须使用前缀索引 单张表的索引数量理论上应控制在5个以内。经常有大批量插入、更新操作表，应尽量少建索引，索引建立的原则理论上是多读少写的场景。 ORDER BY，GROUP BY，DISTINCT的字段需要添加在索引的后面，形成覆盖索引 正确理解和计算索引字段的区分度，文中有计算规则，区分度高的索引，可以快速得定位数据，区分度太低，无法有效的利用索引，可能需要扫描大量数据页，和不使用索引没什么差别。 正确理解和计算前缀索引的字段长度，文中有判断规则，合适的长度要保证高的区分度和最恰当的索引存储容量，只有达到最佳状态，才是保证高效率的索引。 联合索引注意最左匹配原则：必须按照从左到右的顺序匹配，MySQL会一直向右匹配索引直到遇到范围查询(>、 如：depno=1 and empname>'' and job=1 如果建立(depno,empname,job)顺序的索引，job是用不到索引的。 应需而取策略，查询记录的时候，不要一上来就使用 *，只取需要的数据，可能的话尽量只利用索引覆盖，可以减少回表操作，提升效率。 正确判断是否使用联合索引（上面联合索引的使用那一小节有说明判断规则），也可以进一步分析到索引下推（IPC），减少回表操作，提升效率。 避免索引失效的原则：禁止对索引字段使用函数、运算符操作，会使索引失效。这是实际上就是需要保证索引所对应字段的”干净度“。 模糊查询'%value%'会使索引无效，变为全表扫描，因为无法判断扫描的区间，但是'value%'是可以有效利用索引。 索引覆盖排序字段，这样可以减少排序步骤，提升查询效率 尽量的扩展索引，非必要不新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。 举例子：比如一个品牌表，建立的的索引如下，一个主键索引，一个唯一索引 PRIMARY KEY (id),UNIQUE KEY uni_brand_define (app_id,define_id) 当你同事业务代码中的检索语句如下的时候，应该立即警告了，即没有覆盖索引，也没按照最左前缀原则： select brand_id,brand_name from ds_brand_system where status=? and define_id=? and app_id=? 建议改成如下： select brand_id,brand_name from ds_brand_system where app_id=? and define_id=? and status=? ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 10:02:41 "},"doc/后端/mysql/mysql 主从搭建/mysql 主从搭建.html":{"url":"doc/后端/mysql/mysql 主从搭建/mysql 主从搭建.html","title":"mysql 主从搭建","keywords":"","body":"mysql 主从搭建 目录 简介 主从复制的方式 主从复制流程 docker 搭建 文件结构 主master 从 docker compose sql 异常解决 恢复同步 简介 在当前查多读少的业务下， 我们迫切的需要读写分离， 并且需要数据库支持伸缩。这样我们可以多台数据库分摊请求， 减少单库的访问压力。 优点： 负载均衡 异地容灾备份 高可用 高扩展性 缺点： 写入变慢， 因为只有主库可以写入，并且主库同时也要写入日志。 从库有数据延迟 成本增加，性能消耗。 主从复制的方式 binlog（基于日志） gtid （全局事务标识符） 主从复制流程 主库写入日志到binlog 从库到主库复制日志到中继日志，这一步由io线程完成 从库从中继日志读取日志， 并放到sql中， 这一步有sql线程完成 docker 搭建 文件结构 主master # docker file FROM mysql:latest LABEL author=\"yyt-2860889218@qq.com\" ADD ./master/my.cnf /etc/mysql/my.cnf [mysqld] ## 设置server_id，一般设置为IP，注意要唯一 server_id=100 ## 复制过滤：也就是指定哪个数据库不用同步（mysql库一般不同步） binlog-ignore-db=mysql ## 开启二进制日志功能，可以随便取，最好有含义（关键就是这里了） log-bin=mysql-bin ## 为每个session分配的内存，在事务过程中用来存储二进制日志的缓存 binlog_cache_size=1M ## 主从复制的格式（mixed,statement,row，默认格式是statement） binlog_format=mixed ## 二进制日志自动删除/过期的天数。默认值为0，表示不自动删除。 expire_logs_days=7 ## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。 ## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致 slave_skip_errors=1062 从 #docker file FROM mysql:latest LABEL author=\"yyt-2860889218@qq.com\" ADD ./slave/my.cnf /etc/mysql/my.cnf [mysqld] ## 设置server_id，一般设置为IP，注意要唯一 server_id=101 ## 复制过滤：也就是指定哪个数据库不用同步（mysql库一般不同步） binlog-ignore-db=mysql ## 开启二进制日志功能，以备Slave作为其它Slave的Master时使用 log-bin=mysql-slave1-bin ## 为每个session 分配的内存，在事务过程中用来存储二进制日志的缓存 binlog_cache_size=1M ## 主从复制的格式（mixed,statement,row，默认格式是statement） binlog_format=mixed ## 二进制日志自动删除/过期的天数。默认值为0，表示不自动删除。 expire_logs_days=7 ## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。 ## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致 slave_skip_errors=1062 ## relay_log配置中继日志 relay_log=mysql-relay-bin ## log_slave_updates表示slave将复制事件写进自己的二进制日志 log_slave_updates=1 ## 防止改变数据(除了特殊的线程)，只读模式， root用户不限制 read_only=1 docker compose version: '3' services: mysql-master: container_name: mysql_master build: context: ./ dockerfile: master/Dockerfile restart: always hostname: mysql-master volumes: - ./data/master:/var/lib/mysql environment: - \"MYSQL_ROOT_PASSWORD=123456\" - \"MYSQL_DATABASE=test\" networks: - mysql_master_slave ports: - \"33065:3306\" mysql-slave: container_name: mysql_slave build: context: ./ dockerfile: slave/Dockerfile restart: always hostname: mysql-slave volumes: - ./data/slave:/var/lib/mysql environment: - \"MYSQL_ROOT_PASSWORD=123456\" - \"MYSQL_DATABASE=test\" ports: - \"33066:3306\" networks: - mysql_master_slave networks: mysql_master_slave: sql # 主库 -- 创建用户 CREATE USER 'slave'@'%' IDENTIFIED BY '123456'; GRANT REPLICATION SLAVE ON *.* TO 'slave'@'%'; -- 刷新权限 FLUSH PRIVILEGES; -- 获取相关信息 show master status; ## 从库 -- 在从上设置主库配置信息 CHANGE MASTER TO master_host='mysql-master', master_port=3306, MASTER_USER='slave', MASTER_PASSWORD='123456', MASTER_LOG_FILE='mysql-bin.000003', MASTER_LOG_POS=1150; -- 启动从服务器 start slave; -- 查看配置状态slave_IO_runring,slave_slq_runring show slave status\\G 异常解决 从数据库异常 确认是io线程问题 sql线程问题： 根据日志来恢复数据 主数据库异常 查看相关从数据库日志时间， 谁近就把谁升级为主库 -- 查看配置状态 show slave status\\G # 查看 Last_SQL_Errno，Last_SQL_Error。 # 查看日志文件 show binlog events; show binlog events in 'mysql-bin.000003' ; 恢复同步 #从库执行 stop slave; SET GLOBAL SQL_SLAVE_SKIP_COUNTER = 1; -- 跳过一个事务，可选 start slave; ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 10:02:41 "},"doc/后端/git/git.html":{"url":"doc/后端/git/git.html","title":"git","keywords":"","body":"git 目录 git 初步学习 检出仓库 添加和提交 推送改动 分支 更新和合并 解决冲突 标签 替换本地改动 图形化工具 git 提交规范 msg格式 类型 学习地址： git - the simple guide - no deep shit! http://rogerdudler.github.io/git-guide/index.zh.html Git for Windows We bring the awesome Git VCS to Windows https://gitforwindows.org/ 简介： git工作流： work(工作目录) =>Index(暂存区)=> head（最后一次提交结果）=> 推送到远端仓库 work（工作目录）: 就是我们实际操作的 文件 index（暂存区）: 可以理解成缓冲区， 临时保存我们的改动 head : 最后一次提交结果。 git 初步学习 检出仓库 git clone url filePath（路径） 添加和提交 把我们改动的文件提交到index去。 git add //添加指定文件 git add * //添加所有文件 git commit -m \"代码提交信息\" //提交代码到head 推送改动 把我们的head文件推送到远端仓储中 git push origin master //master 是分支 ， 可以替换成自己的分支 分支 分支的作用： 分支是用来分隔我们的代码。 mast 是默认分支， 我们在其他的分支上开发， 完成后再将他们合并到主干上。 git checkout -b feature_x //创建feature_x 分支 git checkout master //切回分支 git branch -d feature_x //删除分支 git push origin //推送分支到远端仓库 更新和合并 git pull // 拉取并更新本地仓库至最新改动 git merge //合并分支 解决冲突 以上更新和合并可能会出现冲突 ， 这个时候就需要我们手动解决冲突,改完后，我们需要执行 git add //提交 git diff //查看差异 标签 git tag 1.0.0 提交id // 在提交id创建一个标签名为1.0.0 git log // 查看提交id git push origin 标签名 //推送标签名 git tag // 列出本地标签 替换本地改动 git checkout -- //丢弃work 中的改动 图形化工具 Sourcetree | Free Git GUI for Mac and Windows A Git GUI that offers a visual representation of your repositories. Sourcetree is a free Git client for Windows and Mac. https://www.sourcetreeapp.com/ git 提交规范 msg格式 [可选的作用域]: [可选的正文] [可选的脚注] 类型 # 主要type feat: 增加新功能 fix: 修复bug # 特殊type docs: 只改动了文档相关的内容 style: 不影响代码含义的改动，例如去掉空格、改变缩进、增删分号 build: 构造工具的或者外部依赖的改动，例如webpack，npm refactor: 代码重构时使用 revert: 执行git revert打印的message # 暂不使用type test: 添加测试或者修改现有测试 perf: 提高性能的改动 ci: 与CI（持续集成服务）有关的改动 chore: 不修改src或者test的其余修改，例如构建过程或辅助工具的变动 ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 10:02:40 "},"doc/后端/nginx/nginx.html":{"url":"doc/后端/nginx/nginx.html","title":"nginx","keywords":"","body":"nginx 目录 简介 核心文件路径 关键字 安装 windows liunx docker 命令 配置文件结构 负载均衡策略 轮询 加权轮询 最少链接 加权最少链接 ip_hash 普通hash 应用 静态站点 文件服务器 vscode 配置 简介 nginx [engine x] 是一个 HTTP 和反向代理服务器， 邮件代理服务器， 和一个通用的 TCP/UDP 代理服务器， 最初由伊戈尔·西索耶夫撰写。 基本的 HTTP 服务器功能 其他http服务器功能 邮件代理服务器功能 TCP/UDP代理服务器功能 体系结构和可伸缩性 核心文件路径 # 配置文件存放目录 /etc/nginx # 主配置文件 /etc/nginx/conf.d # 程序默认存放位置 /usr/share/nginx/html # 日志默认位置 /var/log/nginx nginx https://nginx.org/en/ 关键字 正向代理， 反向代理， 负载均衡： 轮询，加权轮重，ip hash 动静分离 安装 nginx: download https://nginx.org/en/download.html windows nginx-1.22.1.zip liunx docker # ./conf.d 文件夹下创建default.conf server { listen 80; listen [::]:80; server_name localhost; location / { root /usr/share/nginx/html; index index.html index.htm; } error_page 500 502 503 504 /50x.html; location = /50x.html { root /usr/share/nginx/html; } } version: '3' services: myNginx: image: nginx:latest volumes: - ./conf.d:/etc/nginx/conf.d - ./html:/usr/share/nginx/html - ./log:/var/log/nginx container_name: myNginx ports: - 80:80 restart: always 命令 nginx 启动 nginx -s stop 快速关闭Nginx，可能不保存相关信息，并迅速终止web服务。 nginx -s quit 平稳关闭Nginx，保存相关信息，有安排的结束web服务。 nginx -s reload 因改变了Nginx相关配置，需要重新加载配置而重载。 nginx -s reopen 重新打开日志文件。 nginx -c filename 为 Nginx 指定一个配置文件，来代替缺省的。 nginx -t 不运行，仅仅测试配置文件。nginx 将检查配置文件的语法的正确性，并尝试打开配置文件中所引用到的文件。 nginx -v 显示 nginx 的版本。 nginx -V 显示 nginx 的版本，编译器版本和配置参数。 配置文件结构 全局配置 events { worker_connections 1024; } http { http 配置 upstream xx{ server ip weight=1(权重); //负载均衡 ： 服务器资源 } server { listen 8080; server_name localhost; //代理 location / { root html; index index.html index.htm; proxy_pass 协议+xx; } } server { listen 8080; server_name localhost; //代理 location / { root html; index index.html index.htm; proxy_pass 协议+xx; } } } 示例 #运行用户 #user nobody; #启动进程,通常设置成和cpu的数量相等 worker_processes 1; #启动进程,通常设置成和cpu的数量相等 #error_log logs/error.log; #error_log logs/error.log notice; #error_log logs/error.log info; #PID文件，记录当前启动的nginx的进程ID #pid logs/nginx.pid; #工作模式及连接数上限 events { worker_connections 1024;#单个后台worker process进程的最大并发链接数 } #设定http服务器，利用它的反向代理功能提供负载均衡支持 http { #设定mime类型(邮件支持类型),类型由mime.types文件定义 include mime.types; default_type application/octet-stream; #设定日志 #log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' # '$status $body_bytes_sent \"$http_referer\" ' # '\"$http_user_agent\" \"$http_x_forwarded_for\"'; #access_log logs/access.log main; #sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，对于普通应用， #必须设为 on,如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，以平衡磁盘与网络I/O处理速度，降低系统的uptime. sendfile on; #tcp_nopush on; #连接超时时间 #keepalive_timeout 0; keepalive_timeout 65; #gzip压缩开关 #gzip on; #设定实际的服务器列表 upstream test{ #weigth参数表示权值，权值越高被分配到的几率越大 server 127.0.0.1:8080 weight=1; server 127.0.0.1:8081 weight=1; } #HTTP服务器 server { #监听80端口，80端口是知名端口号，用于HTTP协议 listen 80; #定义使用www.xx.com访问 server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / { #指向webapp的目录 #root的处理结果是：root路径＋location路径 #alias的处理结果是：使用alias路径替换location路径 root html; alias html; #首页 index index.html index.htm; #反向代理的路径（和upstream绑定），location 后面设置映射的路径 proxy_pass http://test; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ { # proxy_pass http://127.0.0.1; #} # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ { # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #} #禁止访问 .htxxx 文件 # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\\.ht { # deny all; #} } # another virtual host using mix of IP-, name-, and port-based configuration # #server { # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / { # root html; # index index.html index.htm; # } #} # HTTPS server # #server { # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / { # root html; # index index.html index.htm; # } #} } 负载均衡策略 轮询 加权轮询 最少链接 加权最少链接 ip hash 普通hash 轮询 upstream bck_testing_01 { # 默认所有服务器权重为 1 server 192.168.250.220:8080 server 192.168.250.221:8080 server 192.168.250.222:8080 } 加权轮询 upstream bck_testing_01 { server 192.168.250.220:8080 weight=3 server 192.168.250.221:8080 # default weight=1 server 192.168.250.222:8080 # default weight=1 } 最少链接 分配给最少链接的服务器 upstream bck_testing_01 { least_conn; # with default weight for all (weight=1) server 192.168.250.220:8080 server 192.168.250.221:8080 server 192.168.250.222:8080 } 加权最少链接 upstream bck_testing_01 { least_conn; server 192.168.250.220:8080 weight=3 server 192.168.250.221:8080 # default weight=1 server 192.168.250.222:8080 # default weight=1 } ip_hash upstream bck_testing_01 { ip_hash; # with default weight for all (weight=1) server 192.168.250.220:8080 server 192.168.250.221:8080 server 192.168.250.222:8080 } 普通hash upstream bck_testing_01 { hash $request_uri; # with default weight for all (weight=1) server 192.168.250.220:8080 server 192.168.250.221:8080 server 192.168.250.222:8080 } 应用 多个webapp配置 静态站点 文件服务器 静态站点 html 文件和一堆静态资源 server { listen 8090; server_name localhost; location / { root C:/Users/24514/Desktop/nginx/html; index home.html home.htm; } error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } 文件服务器 Nginx 中的配置要点： 将 autoindex 开启可以显示目录，默认不开启。 将 autoindex_exact_size 开启可以显示文件的大小。 将 autoindex_localtime 开启可以显示文件的修改时间。 root 用来设置开放为文件服务的根路径。 charset 设置为 charset utf-8,gbk;，可以避免中文乱码问题（windows 服务器下设置后，依然乱码，本人暂时没有找到解决方法）。 autoindex on;# 显示目录 autoindex_exact_size on;# 显示文件大小 autoindex_localtime on;# 显示文件时间 server { charset utf-8,gbk; # windows 服务器下设置后，依然乱码，暂时无解 listen 9050 default_server; listen [::]:9050 default_server; server_name _; root /share/fs; } ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-11 10:57:08 "},"doc/后端/nginx/nginx获取用户真实ip-/nginx获取用户真实ip-.html":{"url":"doc/后端/nginx/nginx获取用户真实ip-/nginx获取用户真实ip-.html","title":"nginx获取用户真实ip ","keywords":"","body":"nginx获取用户真实ip server { listen 8000; server_name localhost; location / { # 配置根目录 root /usr/share/nginx/html; # 配置首页 index index.html; # nginx 主机ip proxy_set_header Host $proxy_host; # 获取客户真实ip 解决方案1 proxy_set_header X-Real-IP $remote_addr; # 获取客户真实ip 解决方案2 proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # $host：nginx主机ip # $http_host：nginx主机ip和端口 # $proxy_host: proxy_pass配置的主机名和端口 # $remote_addr:用户真实ip } } ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 10:02:41 "},"doc/后端/nginx/高级nginx/高级nginx.html":{"url":"doc/后端/nginx/高级nginx/高级nginx.html","title":"高级nginx","keywords":"","body":"高级nginx Nginx 一网打尽：动静分离、压缩、缓存、黑白名单、跨域、高可用、性能优化... 早期的业务都是基于单体节点部署，由于前期访问流量不大，因此单体结构也可满足需求，但随着业务增长，流量也越来越大，那么最终单台服务器受到的访问压力也... https://segmentfault.com/a/1190000043430175?utm_source=sf-similar-article ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 10:02:41 "},"doc/后端/go/go.html":{"url":"doc/后端/go/go.html","title":"go","keywords":"","body":"go 目录 基础 常用包 框架 基础 数组，切片的 curd 字典map的 接口和反射 goroutine channel 常用包 文件读取 时间处理 字符串处理 xml,json 处理 正则处理 锁和sync 网络处理 logrus gorm xorm sqlx 框架 gin git 持续集成发布 redis ,etcd docker grpc ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-11 10:58:18 "},"doc/后端/go/入门/入门.html":{"url":"doc/后端/go/入门/入门.html","title":"入门","keywords":"","body":"入门 目录 下载 编辑器 vscode goland 入门 hello world hello 1world go 模块 多模块工作区入门 下载 Download and install - The Go Programming Language https://golang.google.cn/doc/install 编辑器 vscode 安装插件: Go,Go Test Explorer,go-swagger 配置go代理 Goproxy.cn The most trusted Go module proxy in China. https://goproxy.cn/ ```cmake title=\"cmd\" go env -w GO111MODULE=on go env -w GOPROXY=https://goproxy.cn,direct ``` ctrl+shift+p 输入go , 下载go相关工具链 goland 入门 Tutorial: Get started with Go - The Go Programming Language https://golang.google.cn/doc/tutorial/getting-started hello world # 创建hello工程 go mod init hello # 使用go run 运行 go run . 或者 go run 文件名.go package main import \"fmt\" func main() { fmt.Println(\"Hello World\") } hello 1world package main import ( \"fmt\" \"rsc.io/quote\" ) func main() { fmt.Println(quote.Go()) } go 模块 对应代码2.1模块, 2.模块 Tutorial: Create a Go module - The Go Programming Language https://golang.google.cn/doc/tutorial/create-module 创建模块 -- 编写一个包含可从中调用的函数的小模块 另一个模块。 go mod init example.com/greetings 从另一个模块调用您的代码-- 导入并使用您的新模块。 go mod edit -replace (包名)=(到本地项目文件夹名称) go mod tidy go run . 返回并处理错误-- 添加简单 错误处理。 errors.New(\"自定义错误\") 返回随机问候语 -- 处理数据 在切片中（Go 的动态大小的数组）。 向多个人返回问候-- 在映射中存储键/值对。 添加测试-- 使用 Go 的内置单元测试 功能来测试您的代码。 go test 返回全部测试 go test -v 返回每个函数的 编译并安装应用程序-- 在本地编译和安装您的代码。 go build Go 代码被分组到包中，而包被分组到模块中。你 module 指定运行代码所需的依赖项，包括 Go version 及其所需的其他模块集 多模块工作区入门 ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 10:02:40 "},"doc/后端/go/基础知识点/基础知识点.html":{"url":"doc/后端/go/基础知识点/基础知识点.html","title":"基础知识点","keywords":"","body":"基础知识点 目录 声明 变量 类型零值 简单声明 new函数 变量的生命周期 内存逃逸 Go语言中类似if和switch的关键字有25个； 关键字不能用于自定义名字，只能在特定语法结构中使用。 break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var 此外，还有大约30多个预定义的名字，比如int和true等，主要对应内建的常量、类型和函数。 内建常量: true false iota nil 内建类型: int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr float32 float64 complex128 complex64 bool byte rune string error 内建函数: make len cap new append copy close delete complex real imag panic recover 声明 Go语言主要有四种类型的声明语句：var、const、type和func，分别对应变量、常量、类型和函数实体对象的声明。 变量 var 变量名字 类型 = 表达式 其中“类型”或“= 表达式”两个部分可以省略其中的一个。 如果省略的是类型信息，那么将根据初始化表达式来推导变量的类型信息。 如果初始化表达式被省略，那么将用零值初始化该变量。 类型零值 数值类型变量对应的零值是0， 布尔类型变量对应的零值是false， 字符串类型对应的零值是空字符串， 接口或引用类型（包括slice、指针、map、chan和函数）变量对应的零值是nil。 数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。 零值初始化机制可以确保每个声明的变量总是有一个良好定义的值，因此在Go语言中不存在未初始化的变量。 简单声明 名字 := 表达式 变量的类型根据表达式来自动推导。 简短变量声明左边的变量可能并不是全部都是刚刚声明的。 如果有一些已经在相同的词法域声明过了，那么简短变量声明语句对这些已经声明过的变量就只有赋值行为了。 new函数 表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为*T。 变量的生命周期 包：它们的生命周期和整个程序的运行周期是一致的 局部变量： 生命周期是动态的每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。 函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建。 内存逃逸 var global *int func f() { var x int // 这里我们本来是要分配到栈上的 ， 但是因为global的引用，所以这里我们需要分配到堆上。 x = 1 global = &x } func g() { y := new(int) *y = 1 } f函数里的x变量必须在堆上分配，因为它在函数退出后依然可以通过包一级的global变量找到，虽然它是在函数内部定义的； 用Go语言的术语说，这个x局部变量从函数f中逃逸了。 相反，当g函数返回时，变量*y将是不可达的，也就是说可以马上被回收的。 逃逸的变量需要额外分配内存，同时对性能的优化可能会产生细微的影响 ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 10:02:41 "},"doc/后端/go/技巧/技巧.html":{"url":"doc/后端/go/技巧/技巧.html","title":"技巧","keywords":"","body":"技巧 空判断 moldel =(model{}) ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 10:02:41 "},"doc/后端/go/IO/IO.html":{"url":"doc/后端/go/IO/IO.html","title":"IO","keywords":"","body":"IO 目录 io包 reader 接口 writer 接口 接口实现 ReaderAt 和 WriterAt 接口 ReaderAt 接口 WriterAt 接口 ReaderFrom 和 WriterTo 接口 ReadFrom 接口 WriterTo接口 seeker 接口 whence 的值 在io包中定义相应的常量 Closer接口 小提示 Copy 和 CopyN 函数 copy CopyN WriteString 函数 io包 在 io 包中最重要的是两个接口：Reader 和 Writer 接口。本章所提到的各种 IO 包，都跟这两个接口有关，也就是说，只要满足这两个接口，它就可以使用 IO 包的功能。 Reader 接口 reader 接口 Read 将 len(p) 个字节读取到 p 中。它返回读取的字节数 n（0 当 Read 在成功读取 n > 0 个字节后遇到一个错误或 EOF (end-of-file)，它会返回读取的字节数。它可能会同时在本次的调用中返回一个non-nil错误,或在下一次的调用中返回这个错误（且 n 为 0）。 一般情况下, Reader会返回一个非0字节数n, 若 n = len(p) 个字节从输入源的结尾处由 Read 返回，Read可能返回 err == EOF 或者 err == nil。并且之后的 Read() 都应该返回 (n:0, err:EOF)。 调用者在考虑错误之前应当首先处理返回的数据。这样做可以正确地处理在读取一些字节后产生的 I/O 错误，同时允许EOF的出现。 type Reader interface { Read(p []byte) (n int, err error) } writer 接口 Write 将 len(p) 个字节从 p 中写入到基本数据流中。它返回从 p 中被写入的字节数 n（0 type Writer interface { Write(p []byte) (n int, err error) } 接口实现 os.File 同时实现了 io.Reader 和 io.Writer strings.Reader 实现了 io.Reader bufio.Reader/Writer 分别实现了 io.Reader 和 io.Writer bytes.Buffer 同时实现了 io.Reader 和 io.Writer bytes.Reader 实现了 io.Reader compress/gzip.Reader/Writer 分别实现了 io.Reader 和 io.Writer crypto/cipher.StreamReader/StreamWriter 分别实现了 io.Reader 和 io.Writer crypto/tls.Conn 同时实现了 io.Reader 和 io.Writer encoding/csv.Reader/Writer 分别实现了 io.Reader 和 io.Writer mime/multipart.Part 实现了 io.Reader net/conn 分别实现了 io.Reader 和 io.Writer(Conn接口定义了Read/Write) ReaderAt 和 WriterAt 接口 ReaderAt 接口 ReadAt 从基本输入源的偏移量 off 处开始，将 len(p) 个字节读取到 p 中。它返回读取的字节数 n（0 当 ReadAt 返回的 n 即使 ReadAt 返回的 n 若 n = len(p) 个字节从输入源的结尾处由 ReadAt 返回，Read可能返回 err == EOF 或者 err == nil 若 ReadAt 携带一个偏移量从输入源读取，ReadAt 应当既不影响偏移量也不被它所影响。 可对相同的输入源并行执行 ReadAt 调用。 type ReaderAt interface { ReadAt(p []byte, off int64) (n int, err error) } WriterAt 接口 WriteAt 从 p 中将 len(p) 个字节写入到偏移量 off 处的基本数据流中。它返回从 p 中被写入的字节数 n（0 若 WriteAt 携带一个偏移量写入到目标中，WriteAt 应当既不影响偏移量也不被它所影响。 若被写区域没有重叠，可对相同的目标并行执行 WriteAt 调用。 type WriterAt interface { WriteAt(p []byte, off int64) (n int, err error) } 📌注： 这里是左闭右开区间 ， 会覆盖掉原有数据 ReaderFrom 和 WriterTo 接口 ReadFrom 接口 ReadFrom 从 r 中读取数据，直到 EOF 或发生错误。其返回值 n 为读取的字节数。除 io.EOF 之外，在读取过程中遇到的任何错误也将被返回。 如果 ReaderFrom 可用，Copy 函数就会使用它。 type ReaderFrom interface { ReadFrom(r Reader) (n int64, err error) } 注意：ReadFrom 方法不会返回 err == EOF。 WriterTo接口 WriteTo 将数据写入 w 中，直到没有数据可写或发生错误。其返回值 n 为写入的字节数。 在写入过程中遇到的任何错误也将被返回。 如果 WriterTo 可用，Copy 函数就会使用它。 type WriterTo interface { WriteTo(w Writer) (n int64, err error) } seeker 接口 Seek 设置下一次 Read 或 Write 的偏移量为 offset，它的解释取决于 whence： 0 表示相对于文件的起始处，1 表示相对于当前的偏移，而 2 表示相对于其结尾处。 Seek 返回新的偏移量和一个错误，如果有的话。 type Seeker interface { Seek(offset int64, whence int) (ret int64, err error) } whence 的值 在io包中定义相应的常量 const ( SeekStart = 0 // seek relative to the origin of the file SeekCurrent = 1 // seek relative to the current offset SeekEnd = 2 // seek relative to the end ) Closer接口 该接口比较简单，只有一个 Close() 方法，用于关闭数据流。 文件 (os.File)、归档（压缩包）、数据库连接、Socket 等需要手动关闭的资源都实现了 Closer 接口。 实际编程中，经常将 Close 方法的调用放在 defer 语句中。 type Closer interface { Close() error } 小提示 file.Close() 应该在err检查后再调用 file, err := os.Open(\"studygolang.txt\") defer file.Close() if err != nil { ... } Copy 和 CopyN 函数 copy Copy 将 src 复制到 dst，直到在 src 上到达 EOF 或发生错误。它返回复制的字节数，如果有错误的话，还会返回在复制时遇到的第一个错误。 成功的 Copy 返回 err == nil，而非 err == EOF。由于 Copy 被定义为从 src 读取直到 EOF 为止，因此它不会将来自 Read 的 EOF 当做错误来报告。 若 dst 实现了 ReaderFrom 接口，其复制操作可通过调用 dst.ReadFrom(src) 实现。此外，若 src 实现了 WriterTo 接口，其复制操作可通过调用 src.WriteTo(dst) 实现。 func Copy(dst Writer, src Reader) (written int64, err error) CopyN CopyN 将 n 个字节(或到一个error)从 src 复制到 dst。 它返回复制的字节数以及在复制时遇到的最早的错误。当且仅当err == nil时,written == n 。 若 dst 实现了 ReaderFrom 接口，复制操作也就会使用它来实现。 func CopyN(dst Writer, src Reader, n int64) (written int64, err error) WriteString 函数 WriteString 将s的内容写入w中，当 w 实现了 WriteString 方法时，会直接调用该方法，否则执行 w.Write([]byte(s))。 func WriteString(w Writer, s string) (n int, err error) ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 10:02:40 "},"doc/后端/go/os/os.html":{"url":"doc/后端/go/os/os.html","title":"os","keywords":"","body":"os 目录 文件权限 文件权限 0777表示：创建了一个普通文件，所有人拥有所有的读、写、执行权限 0666表示：创建了一个普通文件，所有人拥有对该文件的读、写权限，但是都不可执行 0644表示：创建了一个普通文件，文件所有者对该文件有读写权限，用户组和其他人只有读权限，都没有执行权限 ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 10:02:40 "},"doc/后端/go/gc工作原理/gc工作原理.html":{"url":"doc/后端/go/gc工作原理/gc工作原理.html","title":"gc工作原理","keywords":"","body":"gc工作原理 最常见的垃圾回收算法有标记清除(Mark-Sweep) 和引用计数(Reference Count)，Go 语言采用的是标记清除算法。并在此基础上使用了三色标记法和写屏障技术，提高了效率。 标记清除收集器是跟踪式垃圾收集器，其执行过程可以分成标记（Mark）和清除（Sweep）两个阶段： 标记阶段 — 从根对象出发查找并标记堆中所有存活的对象； 清除阶段 — 遍历堆中的全部对象，回收未被标记的垃圾对象并将回收的内存加入空闲链表。 标记清除算法的一大问题是在标记期间，需要暂停程序（Stop the world，STW），标记结束之后，用户程序才可以继续执行。为了能够异步执行，减少 STW 的时间，Go 语言采用了三色标记法。 三色标记算法将程序中的对象分成白色、黑色和灰色三类。 白色：不确定对象。 灰色：存活对象，子对象待处理。 黑色：存活对象。 标记开始时，所有对象加入白色集合（这一步需 STW ）。首先将根对象标记为灰色，加入灰色集合，垃圾搜集器取出一个灰色对象，将其标记为黑色，并将其指向的对象标记为灰色，加入灰色集合。重复这个过程，直到灰色集合为空为止，标记阶段结束。那么白色对象即可需要清理的对象，而黑色对象均为根可达的对象，不能被清理。 三色标记法因为多了一个白色的状态来存放不确定对象，所以后续的标记阶段可以并发地执行。当然并发执行的代价是可能会造成一些遗漏，因为那些早先被标记为黑色的对象可能目前已经是不可达的了。所以三色标记法是一个 false negative（假阴性）的算法。 三色标记法并发执行仍存在一个问题，即在 GC 过程中，对象指针发生了改变。比如下面的例子： 1 A (黑) -> B (灰) -> C (白) -> D (白) 正常情况下，D 对象最终会被标记为黑色，不应被回收。但在标记和用户程序并发执行过程中，用户程序删除了 C 对 D 的引用，而 A 获得了 D 的引用。标记继续进行，D 就没有机会被标记为黑色了（A 已经处理过，这一轮不会再被处理）。 1 2 3 A (黑) -> B (灰) -> C (白) ↓ D (白) 为了解决这个问题，Go 使用了内存屏障技术，它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码，类似于一个钩子。垃圾收集器使用了写屏障（Write Barrier）技术，当对象新增或更新时，会将其着色为灰色。这样即使与用户程序并发执行，对象的引用发生改变时，垃圾收集器也能正确处理了。 一次完整的 GC 分为四个阶段： 1）标记准备(Mark Setup，需 STW)，打开写屏障(Write Barrier) 2）使用三色标记法标记（Marking, 并发） 3）标记结束(Mark Termination，需 STW)，关闭写屏障。 4）清理(Sweeping, 并发) 参考 fullstack ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 10:02:40 "},"doc/后端/go/database/database.html":{"url":"doc/后端/go/database/database.html","title":"database","keywords":"","body":"database 目录 功能 前置条件 链接数据库 知识点 ： 执行sql 知识点 单个查询 知识点 多个查询 知识点 sql复用语法Prepare 事务 知识点 功能 链接数据库 ping 数据库链接池设置 最大链接数量 空闲时最大链接数量 单个查询 多个查询 执行sql 新增，更新， 删除 sql复用语法 事务 前置条件 create table student( id bigint primary key auto_increment not null comment '主键', name varchar(50) default '' not null comment '名称', age int default 0 not null comment '年龄' ) 链接数据库 这里我们采用链接mysql数据库 import ( \"database/sql\" //导入官方包 _ \"github.com/go-sql-driver/mysql\" //加载mysql 驱动 ) 知识点 ： mysql dns 链接字符串: dns:= \"root:123456\\@tcp(127.0.0.1:3306)/test_db\" 账号：密码@tcp（ip：端口）/链接数据库名称 sql.Open 创建链接结构体sql.Open(\"数据库名称（mysql）\",dns) sqlDb.SetConnMaxLifetime 设置最大活动链接数量 sqlDb.SetConnMaxIdleTime 设置最大空闲链接数量 sqlDb.ping() 真正链接数据 var sqlDb *sql.DB const dns = \"root:123456@tcp(127.0.0.1:3306)/test_db\" func init() { var err error // 创建sql链接数据结构：这里并没有真正的 链接 // 这里为啥要单独声明err呢， 如果这里不单独申明的话 // 下面就会用： 来进行赋值， 这样sqldb就是个包的局部变量 sqlDb, err = sql.Open(\"mysql\", dns) if err != nil { log.Fatalln(\"创建mysql配置错误，\", err) } // 这里我们第一次ping 链接数据 if err = sqlDb.Ping(); err != nil { log.Fatalln(\"mysql数据库链接失败，\", err) } log.Println(\"mysql数据库链接成功dns=\", dns) // 设置最大活动链接数量 sqlDb.SetConnMaxLifetime(100) // 设置最大空闲链接数量 sqlDb.SetConnMaxIdleTime(10) } 执行sql 这个操作可以实现： 新增， 修改， 删除功能 func (s *student) Insert() (err error) { // 执行sql语句 sqlResult, err := sqlDb.Exec(\"insert into student (name, age) values (?,?);\", s.Name, s.Age) if err != nil { return } // 获取最新id s.Id, err = sqlResult.LastInsertId() if err != nil { return } // 获取影响行数 rowNum, err := sqlResult.RowsAffected() log.Println(\"新增影响行数rowNum=\", rowNum) return } 知识点 sqlDb.Exec(sqlstr)： 执行sql sqlResult.LastInsertId() ： 获取最新id sqlResult.RowsAffected()： 获取影响行数 占位符： mysql: ？ 单个查询 查询单个对象 // QueryStudentById 根据id查询 func (s *student) QueryStudentById() (err error) { sqlStr := \"select id, name, age from student where id=?\" // 查询单行 row := sqlDb.QueryRow(sqlStr, s.Id) s = new(student) // 映射到结构体上， 这里需要指针地址 err = row.Scan(&s.Id, &s.Name, &s.Age) return } 知识点 sqlDb.QueryRow(sqlStr, args) : 查询，返回一行数据 row.scan(any) ： 把一行数据，映射到结构体上这里我们需要用到指针 多个查询 查询 多个对象 // QueryStudentBy 根据年龄查询分页 func (s *student) QueryStudentBy() (data []student, err error) { sqlStr := \"select id, name, age from student where age >= ?\" rows, err := sqlDb.Query(sqlStr, s.Age) if err != nil { return } defer rows.Close() for rows.Next() { info := student{} err = rows.Scan(&info.Id, &info.Name, &info.Age) if err != nil { return } data = append(data, info) } return } 知识点 sql.Qery(sqlStr,args) : 查询多个，返回数据集 rows 数据集需要close 释放 row.Next() : 判断是否还有下一行数据集 row.scan(any) ： 把该行数据映射到结构体上 sql复用语法Prepare sqlStr = \"select id, name, age from student where age >= ? order by id Desc limit ?,? \" stmt, err := sqlDb.Prepare(sqlStr) if err != nil { return } rows, err := stmt.Query(s.Age, skipNum, pageSize) if err != nil { return } defer rows.Close() for rows.Next() { info := student{} err = rows.Scan(&info.Id, &info.Name, &info.Age) if err != nil { return } data = append(data, info) } 事务 func Tx() (err error) { // 开始事务 tx, err := sqlDb.Begin() if err != nil { log.Fatal(err) } _, err = tx.Exec(\"update student set age=20 where id=1\") if err != nil { // 回滚事务 tx.Rollback() } row := tx.QueryRow(\"select count(*) from1 student;\") count := 0 err = row.Scan(&count) if err != nil { log.Println(\"事务查询错误：\", err) tx.Rollback() } // 提交事务 tx.Commit() return } 知识点 tx,err := sqlDb.BeginTx() ： 开始事务 tx.Commit() ： 提交事务 tx.Rollback() : 回滚事务 ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 10:02:40 "},"doc/后端/liunx/liunx.html":{"url":"doc/后端/liunx/liunx.html","title":"liunx","keywords":"","body":"liunx liunx ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-11 11:14:22 "},"doc/后端/liunx/挂载硬盘/挂载硬盘.html":{"url":"doc/后端/liunx/挂载硬盘/挂载硬盘.html","title":"挂载硬盘","keywords":"","body":"挂载硬盘 Linux中挂载详解以及mount命令用法_daydayup654的博客-CSDN博客 挂载概念Linux中的根目录以外的文件要想被访问，需要将其“关联”到根目录下的某个目录来实现，这种关联操作就是“挂载”，这个目录就是“挂载点”，解除次关联关系的过程称之为“卸载”。注意：“挂载点”的目录需要以下几个要求：（1）目录事先存在，可以用mkdir命令新建目录；（2）挂载点目录不可被其他进程使用到；（3）挂载点下原有文件将被隐藏。挂载与卸载挂载方法：_ mount https://blog.csdn.net/daydayup654/article/details/78788310 sudo apt-get install nfs-common # 格式化磁盘 mkfs -t ext4 /dev/sda1 # 查看磁盘信息 fdisk -l # 创建挂载点文件夹 mkdir /home/disk1 # 列出磁盘使用空间 df -h # 挂载命令 mount /dev/sda2 /home/otherdisk # 卸载 umount /home/otherdisk # 查看是哪些进程在使用 fuser -cu /data1/img # kill fuser -ck /data1/img ### 开机自动挂载 # 查看分区id sudo blkid # 编辑配置文件 vim /etc/fstab UUID=(blkid uuid) /home/otherdisk/ (blkid type) auto,user,nofail,rw 0 0 ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 10:02:41 "},"doc/后端/liunx/liunx 账号远程登录相关问题-/liunx 账号远程登录相关问题-.html":{"url":"doc/后端/liunx/liunx 账号远程登录相关问题-/liunx 账号远程登录相关问题-.html","title":"liunx 账号远程登录相关问题 ","keywords":"","body":"liunx 账号远程登录相关问题 开启root 远程登录权限 开启普通账户免密登录 开启root账号免密登录 liunx 配置文件vi /etc/ssh/sshd_config 注意修改配置文件需要重启sshd服务 service ssh restart 配置解析 // 开启root登录 PermitRootLogin yes // 开启免密登录 PasswordAuthentication no PermitEmptyPasswords yes 重启sshd服务 service ssh restart // 添加账号 adduser 账号 ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 10:02:41 "},"doc/后端/liunx/ssh/ssh.html":{"url":"doc/后端/liunx/ssh/ssh.html","title":"ssh","keywords":"","body":"ssh 目录 配置账户免密登录 windos cmd 生成key windos .ssh config 多ssh 管理 相关命令 ssh-keygen 配置账户免密登录 windos cmd 生成key # 生成rsa key 备注-c： 树莓派 , 生成到指定目录 -f ssh-keygen -C '树莓派' -f smp_id_rsa #然后回车生成key # 看输出信息看生成的文件放在 哪里 # 一般在账号/.ssh文件下 id_rsa 是私钥 id_rsa.pub 是公钥，公钥需要放到服务器上 windos .ssh config 多ssh 管理 win目录：用户/.ssh/config Host 目标主机标识 HostName 目标主机实际ip Port 端口 User 用户 # 强制使用publickey模式 PreferredAuthentications publickey # 使用秘钥地址 IdentityFile C:\\Users\\xxx\\.ssh\\my-gitea 相关命令 ## 创建 ssh-keygen -C '树莓派' -f smp_id_rsa -t 秘钥类型rsa -C 提供一个注释 -f 指定秘钥生成的文件名称 # 测试 ssh -T （config Host文件）git@github.com # 将公钥复制到远程主机上 ssh-copy-id -i (路径) ldz@192.168.0.1 ssh-keygen -t 秘钥类型rsa -C 提供一个注释 -f 指定秘钥生成的文件名称 ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 10:02:41 "},"doc/后端/liunx/更换源，更新软件包/更换源，更新软件包.html":{"url":"doc/后端/liunx/更换源，更新软件包/更换源，更新软件包.html","title":"更换源，更新软件包","keywords":"","body":"更换源，更新软件包 目录 更换源 更换源 # 备份源 sudo cp /etc/apt/sources.list /etc/apt/sources_init.list sudo vim /etc/apt/sources.list # 更好阿里源 # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse # 预发布软件源，不建议启用 # deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse # 修复损坏的源 sudo apt-get -f install # 更新 sudo apt update && sudo apt upgrade -y ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 10:02:41 "},"doc/后端/liunx/ssh 链接/ssh 链接.html":{"url":"doc/后端/liunx/ssh 链接/ssh 链接.html","title":"ssh 链接","keywords":"","body":"ssh 链接 目录 生成key 一台 电脑多个ssh 生成key ssh-keygen -t 目标目录文件名称 -C \"注释\" 中间有三次回车 // 打开目录 ls ~/.ssh/ // 打开公钥 cat ~/.ssh/id_ed25519.pub // 测试 ssh -T 用户名@名称 一台 电脑多个ssh touch ~/.ssh/config Host 名称 HostName 地址 User 用户名 IdentityFile ~/.ssh/id_rsa_github 私钥地址 ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 10:02:41 "},"doc/前端/前端.html":{"url":"doc/前端/前端.html","title":"前端","keywords":"","body":"前端 html js css ts ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-11 11:12:28 "},"doc/前端/html/html.html":{"url":"doc/前端/html/html.html","title":"html","keywords":"","body":"html 目录 html 元素 剖析 HTML 文档 块级元素和内联元素 块级元素 内联元素 空元素 html 头元信息 设置语言 显示字符集 显示图标 其他类型元数据 seo 引入css 和js 注意点 元素 HTML（HyperText Markup Language，超文本标记语言）是一种用来告知浏览器如何组织页面的_标记语言_。HTML 可复杂、可简单，一切取决于 web 开发者。HTML 由一系列的元素组成，这些元素可以用来包围或_标记_不同部分的内容，使其以某种方式呈现或者工作。两端的标签可以使内容变成超链接，以连接到另一个页面；使字体表现为斜体等。 html 元素 剖析 HTML 文档 我的测试站点 这是我的页面 : 声明文档类型。早期的 HTML（大约 1991-1992 年）文档类型声明类似于链接，规定了 HTML 页面必须遵从的良好规则，能自动检测错误和其他有用的东西。文档类型使用类似于这样： HTMLCopy to Clipboard \\http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"> 文档类型是一个历史遗留问题，需要包含它才能使其他东西正常工作。现在，只需要知道 是最短的有效文档声明！ : \">\\ 元素。这个元素包裹了页面中所有的内容，有时被称为根元素。 : \">\\ 元素。这个元素是一个容器，它包含了所有你想包含在 HTML 页面中但不在 HTML 页面中显示的内容。这些内容包括你想在搜索结果中出现的关键字和页面描述、CSS 样式、字符集声明等等。以后的章节中会学到更多相关的内容。 : \">\\ 元素。这个元素代表了不能由其他 HTML 元相关元素表示的元数据，比如 \">\\、\">\\、\">\\、\">\\ 或 \">\\。charset 属性将你的文档的字符集设置为 UTF-8，其中包括绝大多数人类书面语言的大多数字符。有了这个设置，页面现在可以处理它可能包含的任何文本内容。没有理由不对它进行设置，它可以帮助避免以后的一些问题。 : \">\\ 元素。这设置了页面的标题，也就是出现在该页面加载的浏览器标签中的内容。当页面被加入书签时，页面标题也被用来描述该页面。 : \">\\ 元素。包含了你访问页面时_所有_显示在页面上的内容，包含文本、图片、视频、游戏、可播放音频轨道等等。 7. 块级元素和内联元素 在 HTML 中有两种你需要知道的重要元素类别，块级元素和内联元素。 块级元素在页面中以块的形式展现。一个块级元素出现在它前面的内容之后的新行上。任何跟在块级元素后面的内容也会出现在新的行上。块级元素通常是页面上的结构元素。例如，一个块级元素可能代表标题、段落、列表、导航菜单或页脚。一个块级元素不会嵌套在一个内联元素里面，但它可能嵌套在另一个块级元素里面。 内联元素通常出现在块级元素中并环绕文档内容的一小部分，而不是一整个段落或者一组内容。内联元素不会导致文本换行。它通常与文本一起使用，例如，\">\\ 元素创建一个超链接，\">\\ 和 \">\\ 等元素创建强调。 空元素，不是所有元素都拥有开始标签、内容和结束标签。一些元素只有一个标签，通常用来在此元素所在位置插入/嵌入一些东西。这些元素被称为空元素。例如：元素 \">\\ 是用来在页面插入一张指定的图片。 块级元素 内联元素 空元素 html 头元信息 我的测试页面 这是我的页面 HTML 头部包含 HTML \\ 元素的内容，与 \\ 元素内容不同，页面在浏览器加载后它的内容不会在浏览器中显示，它的作用是保存页面的一些元数据 设置语言 显示字符集 显示图标 其他类型元数据 添加作者和描述 ```html 2. 网站提供了更丰富的元数据 ```html seo 引入css 和js 注意点 html 不区分大小写 ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 09:48:08 "},"doc/前端/css/css.html":{"url":"doc/前端/css/css.html","title":"css","keywords":"","body":"css 目录 什么是css 选择器 属性选择器 子字符选择器 伪类伪元素 伪类 伪元素 关系选择器 CSS：一切皆盒子 层叠和继承 优先级： 继承 flex 什么是css 引用css 也就是 和 标签之间 和 HTML 类似，CSS 也不是真正的编程语言，甚至不是标记语言。CSS 是一门样式表语言，这也就是说人们可以用它来选择性地为 HTML 元素添加样式。 选择器（Selector） HTML 元素的名称位于规则集开始。它选择了一个或多个需要添加样式的元素（在这个例子中就是 \">\\ 元素）。要给不同元素添加样式，只需要更改选择器。 声明（Declaration） 一个单独的规则，如 color: red; 用来指定添加样式元素的属性。 属性（Properties） 改变 HTML 元素样式的途径（本例中 color 就是 \">\\ 元素的属性）。CSS 中，由编写人员决定修改哪个属性以改变规则。 属性的值（Property value） 在属性的右边，冒号后面即属性的值，它从指定属性的众多外观中选择一个值（我们除了 red 之外还有很多属性值可以用于 color ）。 注意其他重要的语法： 除了选择器部分，每个规则集都应该包含在成对的大括号里（{}）。 在每个声明里要用冒号（:）将属性与属性值分隔开。 在每个规则集里要用分号（;）将各个声明分隔开。 选择多个用逗号分开 选择器 选择器名称 选择的内容 示例 元素选择器（也称作标签或类型选择器） 所有指定类型的 HTML 元素 p选择 ID 选择器 具有特定 ID 的元素。单一 HTML 页面中，每个 ID 只对应一个元素，一个元素只对应一个 ID #my-id选择 或 类选择器 具有特定类的元素。单一页面中，一个类可以有多个实例 .my-class选择 和 属性选择器 拥有特定属性的元素 img[src]选择 但不是 伪类选择器 特定状态下的特定元素（比如鼠标指针悬停于链接之上） a:hover选择仅在鼠标指针悬停在链接上时的 元素 属性选择器 选择器 示例 描述 [_attr_] a[title] 匹配带有一个名为_attr_的属性的元素——方括号里的值。 [_attr_=_value_] a[href=\"https://example.com\"] 匹配带有一个名为_attr_的属性的元素，其值正为_value_——引号中的字符串。 [_attr_~=_value_] p[class~=\"special\"] 匹配带有一个名为_attr_的属性的元素，其值正为_value_，或者匹配带有一个_attr_属性的元素，其值有一个或者更多，至少有一个和_value_匹配。 注意，在一列中的好几个值，是用空格隔开的。 `[attr\\ =value]` `div[lang\\ =\"zh\"]` 匹配带有一个名为_attr_的属性的元素，其值可正为_value_，或者开始为_value_，后面紧随着一个连字符。 子字符选择器 选择器 示例 描述 [attr^=value] li[class^=\"box-\"] 匹配带有一个名为_attr_的属性的元素，其值开头为_value_子字符串。 [attr$=value] li[class$=\"-box\"] 匹配带有一个名为_attr_的属性的元素，其值结尾为_value_子字符串 [attr*=value] li[class*=\"box\"] 匹配带有一个名为_attr_的属性的元素，其值的字符串中的任何地方，至少出现了一次_value_子字符串。 伪类伪元素 伪类就是开头为冒号的关键字： :pseudo-class-name 伪元素开头为双冒号:: ::pseudo-element-name 伪类 选择器 描述 :active 在用户激活（例如点击）元素的时候匹配。 :any-link 匹配一个链接的:link和:visited状态。 :blank 匹配空输入值的\">\\元素。 :checked 匹配处于选中状态的单选或者复选框。 :current (en-US) 匹配正在展示的元素，或者其上级元素。 :default 匹配一组相似的元素中默认的一个或者更多的 UI 元素。 :dir 基于其方向性（HTMLdir属性或者 CSSdirection属性的值）匹配一个元素。 :disabled 匹配处于关闭状态的用户界面元素 :empty 匹配除了可能存在的空格外，没有子元素的元素。 :enabled 匹配处于开启状态的用户界面元素。 :first 匹配分页媒体的第一页。 :first-child 匹配兄弟元素中的第一个元素。 :first-of-type 匹配兄弟元素中第一个某种类型的元素。 :focus 当一个元素有焦点的时候匹配。 :focus-visible 当元素有焦点，且焦点对用户可见的时候匹配。 :focus-within 匹配有焦点的元素，以及子代元素有焦点的元素。 :future (en-US) 匹配当前元素之后的元素。 :hover 当用户悬浮到一个元素之上的时候匹配。 :indeterminate 匹配未定态值的 UI 元素，通常为复选框。 :in-range 用一个区间匹配元素，当值处于区间之内时匹配。 :invalid 匹配诸如的位于不可用状态的元素。 :lang 基于语言（HTMLlang属性的值）匹配元素。 :last-child 匹配兄弟元素中最末的那个元素。 :last-of-type 匹配兄弟元素中最后一个某种类型的元素。 :left 在分页媒体中，匹配左手边的页。 :link 匹配未曾访问的链接。 :local-link (en-US) 匹配指向和当前文档同一网站页面的链接。 :is() 匹配传入的选择器列表中的任何选择器。 :not 匹配作为值传入自身的选择器未匹配的物件。 :nth-child 匹配一列兄弟元素中的元素——兄弟元素按照_an+b_形式的式子进行匹配（比如 2n+1 匹配元素 1、3、5、7 等。即所有的奇数个）。 :nth-of-type 匹配某种类型的一列兄弟元素（比如，元素）——兄弟元素按照_an+b_形式的式子进行匹配（比如 2n+1 匹配元素 1、3、5、7 等。即所有的奇数个）。 :nth-last-child 匹配一列兄弟元素，从后往前倒数。兄弟元素按照_an+b_形式的式子进行匹配（比如 2n+1 匹配按照顺序来的最后一个元素，然后往前两个，再往前两个，诸如此类。从后往前数的所有奇数个）。 :nth-last-of-type 匹配某种类型的一列兄弟元素（比如，元素），从后往前倒数。兄弟元素按照_an+b_形式的式子进行匹配（比如 2n+1 匹配按照顺序来的最后一个元素，然后往前两个，再往前两个，诸如此类。从后往前数的所有奇数个）。 :only-child 匹配没有兄弟元素的元素。 :only-of-type 匹配兄弟元素中某类型仅有的元素。 :optional 匹配不是必填的 form 元素。 :out-of-range 按区间匹配元素，当值不在区间内的的时候匹配。 :past (en-US) 匹配当前元素之前的元素。 :placeholder-shown 匹配显示占位文字的 input 元素。 :playing 匹配代表音频、视频或者相似的能“播放”或者“暂停”的资源的，且正在“播放”的元素。 :paused 匹配代表音频、视频或者相似的能“播放”或者“暂停”的资源的，且正在“暂停”的元素。 :read-only 匹配用户不可更改的元素。 :read-write 匹配用户可更改的元素。 :required 匹配必填的 form 元素。 :right 在分页媒体中，匹配右手边的页。 :root 匹配文档的根元素。 :scope 匹配任何为参考点元素的的元素。 :valid 匹配诸如元素的处于可用状态的元素。 :target 匹配当前 URL 目标的元素（例如如果它有一个匹配当前URL 分段的元素）。 :visited 匹配已访问链接。 :where 条件 伪元素 选择器 描述 ::after 匹配出现在原有元素的实际内容之后的一个可样式化元素。 ::before 匹配出现在原有元素的实际内容之前的一个可样式化元素。 ::first-letter 匹配元素的第一个字母。 ::first-line 匹配包含此伪元素的元素的第一行。 ::grammar-error 匹配文档中包含了浏览器标记的语法错误的那部分。 ::selection 匹配文档中被选择的那部分。 ::spelling-error 匹配文档中包含了浏览器标记的拼写错误的那部分。 关系选择器 选择器 描述 空格（\" \"）字符——组合两个选择器 body article p 后代选择器 article > p 子代关系选择器是个大于号（>），只会在选择器选中直接子元素的时候匹配 p + img 邻接兄弟选择器（+）用来选中恰好处于另一个在继承关系上同级的元素旁边的物件 p ~ img 通用兄弟， 选中一个元素的兄弟元素，即使它们不直接相邻 CSS：一切皆盒子 编写 CSS 时你会发现，你的工作好像是围绕着一个一个盒子展开的——设置尺寸、颜色、位置，等等。页面里大部分 HTML 元素都可以被看作若干层叠的盒子。 padding（内边距）：是指内容周围的空间。在下面的例子中，它是段落文本周围的空间。 border（边框）：是紧接着内边距的线。 margin（外边距）：是围绕元素边界外侧的空间。 层叠和继承 优先级： 上到下， 先具体后大概 想同权重，则是后面的应用 !importer 最高优先级 继承 inherit设置该属性会使子元素属性和父元素相同。实际上，就是“开启继承”。 initial将应用于选定元素的属性值设置为该属性的初始值。 revert (en-US)将应用于选定元素的属性值重置为浏览器的默认样式，而不是应用于该属性的默认值。在许多情况下，此值的作用类似于 unset。 revert-layer (en-US)将应用于选定元素的属性值重置为在上一个层叠层中建立的值。 unset将属性重置为自然值，也就是如果属性是自然继承那么就是 inherit，否则和 initial 一样 ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 09:48:08 "},"doc/前端/js/js.html":{"url":"doc/前端/js/js.html","title":"js","keywords":"","body":"js 目录 入门 入口函数 js的数据类型 查看数据类型 类型转换 字符串 数组 对象 函数 js 选择器 事件 dom操作 节点关系 节点操作方法 dom 操作html dom操作css dom 中表单与属性操作 属性操作 其他 时间 json 原生 JavaScript 教程 - 长乐未央 https://clwy.cn/guide/documents/javascript-clwy 入门 入口函数 // 当所有文件都已经加载完毕 window.onload = function(){ //其他代码放在这里 } // 按照顺序加载 function welcome(){ alert('欢迎光临长乐未央~'); } js的数据类型 字符串string 数字 number 布尔 Boolean 空 null 未定义 undefined 符号 查看数据类型 // 字符串 var txt = \"欢迎光临\"; console.log(typeof txt); 类型转换 // 转字符串 string(变量) //转数字 parseInt() //转浮点 parseFloat() 字符串 属性或方法 意义 length 属性 长度 charAt 所在位置的字符串 charCodeAt 所在位置字符串的字符编码 concat 拼接多个字符，实际常用 + 拼接 slice 截取 substr 截取 substring 截取 indexOf 字符串所在索引位置 lastIndexOf 从后向前搜索字符串，找到索引位置 trim 去除空格 toLowerCase 转小写 toUpperCase 转大写 split 字符串分割成数组 数组 var cars = [\"Saab\", \"Volvo\", \"BMW\"]; 方法 意义 join 数组连接成字符串 push 从后面推入 unshift 从前面推入 pop 取得并删除最后一项 shift 取得并删除第一项 reverse 反转 sort 排序 concat 连接数组 slice 将数组的一部分复制成新数组 splice 修改数组 (删除、修改、新增) indexOf、lastIndexOf 取得索引值 forEach 遍历数组 map 遍历并返回新数组 对象 创建 // 1. 声明对象 var obj = {} // 2. 构造函数创建 var x = new Object() 定义 // 1 var person = { name: '刘备', age: 29 } // 2 var person = new Object(); person.name = '刘备'; person.age = 29; 函数 // 定义函数 function hello(x) { return \"hello world\"+x; } //执行 hello(); //我就是开关 js 选择器 代码 意义 document.getElementsByTagName 标签选择器 document.getElementById ID 选择器 document.getElementsByClassName Class 选择器 document.getElementsByName 选取带有指定 name 属性的元素 (不常用) document.querySelector HTML5 中新加入的，接受一个 CSS 选择符，只匹配第一个 document.querySelectorAll HTML5 中新加入的， 匹配所有元素 事件 事件 意义 onclick 鼠标单击 ondblclick 鼠标双击 onkeyup 按下并释放键盘上的一个键时触发 onchange 文本内容或下拉菜单中的选项发生改变 onfocus 获得焦点，表示文本框等获得鼠标光标 onblur 失去焦点 onmouseover 鼠标悬停 onmouseout 鼠标移出 onload 网页文档加载事件 onunload 关闭网页时 onsubmit 表单提交事件 onreset 重置表单时 e.stopPropagation() 阻止事件冒泡 // 添加点击事件 btn.addEventListener(\"click\", getMaxByTreeNum); dom操作 方法 意义 createElement 创建元素节点 createTextNode 创建文本节点 节点关系 方法 意义 children 子元素节点，不包含换行等 childNodes 子节点，包含文本、换行等 parentNode 父节点，注意是单数 previousSibling 前一个同辈节点，包括文本节点、注释节点即回车、换行、空格、文本等 previousElementSibling 前一个同辈节点，不包括文本节点、注释节点 nextSibling 后一个同辈节点，包括文本节点、注释节点即回车、换行、空格、文本等 nextElementSibling 后一个同辈节点，不包括文本节点、注释节点等 firstChild 第一个子节点，包含文本 firstElementChild 第一个子节点，不包含文本 lastChild 最后一个子节点，包含文本 lastElementChild 最后一个子节点，不包含文本 节点操作方法 方法 意义 appendChild() 在最后面追加 insertBefore() 参数 1: 要插入的节点 参数 2: 作为参照的节点，如果为 null，与 appendChild 效果相同 replaceChild() 替换节点 参数 1: 要插入的节点 参数 2: 要替换的节点 removeChild() 移除节点 参数: 要移除的节点 cloneNode() 复制节点 参数（可选）：true，克隆时包含子元素 dom 操作html 方法 意义 innerHTML 修改元素内部 HTML outerHTML 获取、修改整个元素的 HTML innerText 修改元素内部文本 outerText 获取、修改整个元素的文本 insertAdjacentHTML(插入位置， html 内容) 插入新的 html dom操作css dom中有个集合：classList var demo = document.getElementById(\"demo\"); console.log(demo.classList); // 新增class demo.classList.add('ghost'); // 删除class demo.classList.remove('big'); // 切换class demo.classList.toggle('blue'); // 是否包含class console.log(demo.classList.contains('blue')); dom 中表单与属性操作 var username = document.getElementById(\"username\"); // 取值 console.log(username.value); // 设置值 user.value = \"pipi\"; 属性操作 方法 意义 getAttribute 得到属性 setAttribute 设置属性 removeAttribute 移除属性 其他 时间 方法 意义 Date() 返回当日的日期和时间。 getDate() 从 Date 对象返回一个月中的某一天 (1~ 31)。 getDay() 从 Date 对象返回一周中的某一天 (0~ 6)。 getMonth() 从 Date 对象返回月份 (0~ 11)。 getFullYear() 从 Date 对象以四位数字返回年份。 getYear() 请使用 getFullYear() 方法代替。 getHours() 返回 Date 对象的小时 (0~ 23)。 getMinutes() 返回 Date 对象的分钟 (0~ 59)。 getSeconds() 返回 Date 对象的秒数 (0~ 59)。 getMilliseconds() 返回 Date 对象的毫秒 (0~ 999)。 getTime() 返回 1970 年 1 月 1 日至今的毫秒数。 getTimezoneOffset() 返回本地时间与格林威治标准时间 (GMT) 的分钟差。 getUTCDate() 根据世界时从 Date 对象返回月中的一天 (1~ 31)。 getUTCDay() 根据世界时从 Date 对象返回周中的一天 (0~ 6)。 getUTCMonth() 根据世界时从 Date 对象返回月份 (0~ 11)。 getUTCFullYear() 根据世界时从 Date 对象返回四位数的年份。 getUTCHours() 根据世界时返回 Date 对象的小时 (0~ 23)。 getUTCMinutes() 根据世界时返回 Date 对象的分钟 (0~ 59)。 getUTCSeconds() 根据世界时返回 Date 对象的秒钟 (0~ 59)。 getUTCMilliseconds() 根据世界时返回 Date 对象的毫秒 (0~ 999)。 parse() 返回 1970 年 1 月 1 日午夜到指定日期（字符串）的毫秒数。 setDate() 设置 Date 对象中月的某一天 (1~ 31)。 setMonth() 设置 Date 对象中月份 (0~ 11)。 setFullYear() 设置 Date 对象中的年份（四位数字）。 setYear() 请使用 setFullYear() 方法代替。 setHours() 设置 Date 对象中的小时 (0~ 23)。 setMinutes() 设置 Date 对象中的分钟 (0~ 59)。 setSeconds() 设置 Date 对象中的秒钟 (0~ 59)。 setMilliseconds() 设置 Date 对象中的毫秒 (0~ 999)。 setTime() 以毫秒设置 Date 对象。 setUTCDate() 根据世界时设置 Date 对象中月份的一天 (1~ 31)。 setUTCMonth() 根据世界时设置 Date 对象中的月份 (0~ 11)。 setUTCFullYear() 根据世界时设置 Date 对象中的年份（四位数字）。 setUTCHours() 根据世界时设置 Date 对象中的小时 (0~ 23)。 setUTCMinutes() 根据世界时设置 Date 对象中的分钟 (0~ 59)。 setUTCSeconds() 根据世界时设置 Date 对象中的秒钟 (0~ 59)。 setUTCMilliseconds() 根据世界时设置 Date 对象中的毫秒 (0~ 999)。 toSource() 返回该对象的源代码。 toString() 把 Date 对象转换为字符串。 toTimeString() 把 Date 对象的时间部分转换为字符串。 toDateString() 把 Date 对象的日期部分转换为字符串。 toGMTString() 请使用 toUTCString() 方法代替。 toUTCString() 根据世界时，把 Date 对象转换为字符串。 toLocaleString() 根据本地时间格式，把 Date 对象转换为字符串。 toLocaleTimeString() 根据本地时间格式，把 Date 对象的时间部分转换为字符串。 toLocaleDateString() 根据本地时间格式，把 Date 对象的日期部分转换为字符串。 UTC() 根据世界时返回 1970 年 1 月 1 日 到指定日期的毫秒数。 valueOf() 返回 Date 对象的原始值。 json 函数 描述 JSON.parse() 用于将一个 JSON 字符串转换为 JavaScript 对象。 JSON.stringify() 用于将 JavaScript 值转换为 JSON 字符串。 js 执行机制 同步任务 从上到下 异步任务 宏任务 script(整体代码)、setTimeout、setInterval、UI交互事件、postMessage、Ajax 微任务 Promise.then catch finally、MutaionObserver、process.nextTick(Node.js 环境) 所有的同步任务都是在主进程执行的形成一个执行栈，主线程之外，还存在一个\"任务队列\"， 异步任务执行队列中先执行宏任务，然后清空当次宏任务中的所有微任务， 然后进行下一个tick如此形成循环。 NextTaick 创建一个异步任务 。 {{ inputA }} import { ref, nextTick } from 'vue'; let inputA = ref(\"测试\") let div = ref() const change = async () => { inputA.value = \"测试ADS\" await nextTick() // 没有await nexTick ：测试 // 测试ADS console.log(div.value?.innerText); } ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 09:53:32 "},"doc/前端/ts/ts.html":{"url":"doc/前端/ts/ts.html","title":"ts","keywords":"","body":"ts [toc] 入门 # 安装ts npm install typescript -g 类型 变量声明 let valName :(type)=val 基础类型(type) TS是JS的超集，所以JS基础的类型都包含在内 | 来支持多种类型 any： 任意类型 string ：字符串 ( ` ` ) 可以用来嵌套文本和表达式 number ： 数字 双精度 64 位浮点值 boolean ： 布尔 [] 数组类型： number[]，Array\\ 元组： 也是数组的一种， 只不过里面的各个元素类型可能不同 let x: [string, number] enum ： 枚举 ，enum Color {Red, Green, Blue}; void ：空 null ： 空 undefined ： 用于初始化变量为一个未定义的值 never ：其它类型（包括 null 和 undefined）的子类型，代表从不会出现的值。 注意： void 和 undefined 和 null 最大的区别 与 void 的区别是，undefined 和 null 是所有类型的子类型。 任意类型 any : 类似与c# 中的T : 没有限制哪种类型 unknown ： 顶级类型， any 弊端如果使用any 就失去了TS类型检测的作用 没有限制哪种类型 unknown 不能调用属性和方法 所有类型都可以分配给它 接口 类似于结构体 关键字interface（接口） 使用interface来定义一种约束，让数据的结构满足约束的格式 //定义接口 interface person extends B{ readonly id :number, name string, age? number, [propName:string]any, cb:()=>{ console.log(123) } } interface B{ xxx:string } //定义函数 interface Fn{ (name:string):number[] } const fn:Fn=(name:string)=>{ return [1] } 接口重名会自动重合 任意key ？，readonly 接口继承 extends 定义函数类型 注： 使用接口约束的时候不能多一个属性也不能少一个属性 必须与接口保持一致 数组类型 在类型后面 加上中括号 let valName :(type[])=val 泛型数组： Array\\ arguments 类数组 arguments类数组 function Arr(...args:any): void { console.log(arguments) //ts内置对象IArguments 定义 let arr:IArguments = arguments } Arr(111, 222, 333) //其中 IArguments 是 TypeScript 中定义好了的类型，它实际上就是： interface IArguments { [index: number]: any; length: number; callee: Function; } 类型断言 类型断言可以用来手动指定一个值的类型，即允许变量从一种类型更改为另一种类型。 值 as 类型 函数 number 对象方法 方法 解释 toFixed() 把数字转换为字符串，并对小数点指定位数。 toLocaleString() 把数字转换为字符串，使用本地数字格式顺序。 toPrecision() 把数字格式化为指定的长度。 toString() 把数字转换为字符串，使用指定的基数。数字的基数是 2 ~ 36 之间的整数。若省略该参数，则使用基数 10。 valueOf() 返回一个 Number 对象的原始数字值。 string 对象方法 属性 length 返回字符串的长度。 prototype 允许您向对象添加属性和方法。 方法 charAt() 返回在指定位置的字符。 charCodeAt() 返回在指定的位置的字符的 Unicode 编码。 concat() 连接两个或更多字符串，并返回新的字符串。 indexOf() 返回某个指定的字符串值在字符串中首次出现的位置。 lastIndexOf() 从后向前搜索字符串，并从起始位置（0）开始计算返回字符串最后出现的位置。 localeCompare() 用本地特定的顺序来比较两个字符串 match() 查找找到一个或多个正则表达式的匹配。 replace() 替换与正则表达式匹配的子串 search() 检索与正则表达式相匹配的值 slice() 提取字符串的片断，并在新的字符串中返回被提取的部分 split() 把字符串分割为子字符串数组。 substr() 从起始索引号提取字符串中指定数目的字符。 substring() 提取字符串中两个指定的索引号之间的字符。 toLocaleLowerCase() 根据主机的语言环境把字符串转换为小写，只有几种语言（如土耳其语）具有地方特有的大小写映射。 toLocaleUpperCase() 据主机的语言环境把字符串转换为大写，只有几种语言（如土耳其语）具有地方特有的大小写映射。 toLowerCase() 把字符串转换为小写。 toString() 返回字符串。 valueOf() 返回指定字符串对象的原始值。 toUpperCase() 把字符串转换为大写。 数组 concat() 连接两个或更多的数组，并返回结果。 every() 检测数值元素的每个元素是否都符合条件。 filter() 检测数值元素，并返回符合条件所有元素的数组。 forEach() 数组每个元素都执行一次回调函数。 indexOf() 搜索数组中的元素，并返回它所在的位置。 如果搜索不到，返回值 -1，代表没有此项。 join() 把数组的所有元素放入一个字符串。 lastIndexOf() 返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索。 map() 通过指定函数处理数组的每个元素，并返回处理后的数组。 pop() 删除数组的最后一个元素并返回删除的元素。 push() 向数组的末尾添加一个或更多元素，并返回新的长度。 reduce() 将数组元素计算为一个值（从左到右）。 reduceRight() 将数组元素计算为一个值（从右到左）。 reverse() 反转数组的元素顺序。 shift() 删除并返回数组的第一个元素。 slice() 选取数组的的一部分，并返回一个新数组。 some() 检测数组元素中是否有元素符合指定条件 sort() 对数组的元素进行排序。 splice() 从数组中添加或删除元素。 toString() 把数组转换为字符串，并返回结果。 unshift() 向数组的开头添加一个或更多元素，并返回新的长度。 接口 interface interface_name { } ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 10:00:49 "},"doc/前端/vue/vue.html":{"url":"doc/前端/vue/vue.html","title":"vue","keywords":"","body":"vue vue 学习 ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-11 11:12:05 "},"doc/前端/vue/脚手架/脚手架.html":{"url":"doc/前端/vue/脚手架/脚手架.html","title":"脚手架","keywords":"","body":"脚手架 目录 vue 脚手架 区别 // 使用vite创建项目 npm init vite@latest 4.0 // 使用vue创建项目 npm init vue@latest // 加载依赖 npm i // 运行项目 npm run dev vite脚手架 // 使用vite创建项目 npm init vite@latest vue 脚手架 // 使用vue创建项目 npm init vue@latest 区别 使用vite 和vue 脚手架搭建项目：vite 可以搭建多种框架的项目， vue是vue专门建立项目。 ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 09:48:09 "},"doc/前端/vue/模板语法-/模板语法-.html":{"url":"doc/前端/vue/模板语法-/模板语法-.html","title":"模板语法 ","keywords":"","body":"模板语法 目录 v-on 示例： v- 开头都是vue 的指令 v-text 用来显示文本 v-html 用来展示富文本 v-if 用来控制元素的显示隐藏（切换真假DOM） v-else-if 表示 v-if 的“else if 块”。可以链式调用 v-else v-if条件收尾语句 v-show 用来控制元素的显示隐藏（display none block Css切换） v-on 简写@ 用来给元素添加事件 v-bind 简写: 用来绑定元素的属性Attr v-model 双向绑定 v-for 用来遍历元素 v-on修饰符 冒泡案例 v-once 性能优化只渲染一次 v-memo 性能优化会有缓存 Vue3.2 新增 v-memo - 掘金 v-on v-on 简写@ 用来给元素添加事件 示例： import { ref } from \"vue\" let msg: string = \"msg\" let msgSplit: string = \"我，是，瑾，语\" let num: number = 1 let msgHtml: string = \"v-html\" let bindId: string = \"1\" let isButtonDisabled = ref(true) let matchBind = { id: \"matchBindId\", class: \"matchBindClass\" } let toTitleDate = (data: string) => { return data + \":test\"; } let btnClick = () => { isButtonDisabled.value = !isButtonDisabled.value console.log(isButtonDisabled) } let iftext: string = \"a\" let forArrary: Array = [\"a\", \"b\", \"c\"] 模板语法 {{ msg }} {{ num == 1 ? '我是瑾语' : '我不是瑾语' }} {{ msgSplit.split(\"，\") }} 测试 bind缩写测试 {{ isButtonDisabled ? \"禁用\" : \"启用\" }} 显示show 点击切换 点击切换缩写 bind动态绑定多个值 bind动态绑定多个值 bind调用函数 bind动态绑定多个值 if指令 a b c for指令 {{ index }}:{{ info }} .matchBindClass { color: red; } #matchBindId { font-size: small; } ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 09:48:09 "},"doc/前端/vue/响应式/响应式.html":{"url":"doc/前端/vue/响应式/响应式.html","title":"响应式","keywords":"","body":"响应式 目录 ref customRef： 自定义 reactive 使用场景 其他知识 toref torefs toraw 响应式原理 ref 支持所有类型 取值，赋值都需要.value ref : 深层响应式更新 isRef ： 判断是否是响应式 shallowRef ：浅应式响应， 注意和ref不能同时使用 ，会导致shallowRef失效 triggerRef ：强制更新 customRef ：自定义ref，函数需要返回cutomRef： get(),set()方法实现 track() 收集依赖 trigger() 更新响应 customRef： 自定义 function MyRef(value: T) { let timer: any = null return customRef((track, trigger) => { return { get() { // 所有依赖搜集 track() return value }, set(newVal: T) { // 防抖 clearTimeout(timer) timer = setTimeout(() => { console.log('请求......'); // 更新触发渲染 value = newVal }, 1000 * 2) trigger() } } }) } reactive 支持引用类型array ， object , map , set 取值，赋值都不需要.value 不能直接赋值proxy ， 否则破坏响应式对象 解决方案： 可以使用push 加解构 添加一个对象吧数组作为一个属性去解决 使用场景 绑定表单 reactive shallowReactive 和shallowRef差不多 ： 浅层响应 其他知识 toref 取出响应式中的 某一个 属性，不能应用非响应式上 let name = toRef(form, \"name\") torefs 和toref一样，取出多个 toraw 把响应式对象转换成原始对象 let formRaw = toRaw(form) 响应式原理 vue3使用的proxy 来实现的 ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 09:48:09 "},"doc/前端/vue/方法/方法.html":{"url":"doc/前端/vue/方法/方法.html","title":"方法","keywords":"","body":"方法 目录 computed : 计算属性 watch监听 watcheffect 高级监听 computed : 计算属性 只要里面所适用的元素有改动 ， 就会自动计算 // 引入computed import { ref, computed } from 'vue'; let sumPrice = ref(0) sumPrice = computed(() => { return data.reduce((prev, next) => { return prev + (next.num * next.price) }, 0) }) watch监听 监听响应式ref，reactive 前后值变化 当监听的是reactive 时候默认开启深度监听，如果是ref则需要手动开启 简单的监听 深度的监听 import { ref, reactive, watch } from 'vue'; let msg1 = ref(\"简单\") let msg2 = ref({ fool: { name: { title: \"深度监听\" } } }) // // 监听多个 // watch([msg1, msg2], (newVal, oldVal) => { // console.log(\"newVal=\", newVal) // console.log(\"oldVal=\", oldVal) // }, { // deep: true,//开启深度监听 // immediate: true,//默认自动先走一次 // flush: \"pre\" // pre 组件更新之前调用，sync 同步执行， post 组件更新之后 // }) // 监听某个属性 watch(() => msg2.value.fool.name.title, (newVal, oldVal) => { console.log(\"newVal=\", newVal) console.log(\"oldVal=\", oldVal) }) watcheffect 高级监听 立即执行传入的一个函数，同时响应式追踪其依赖，并在其依赖变更时重新运行该函数。 如果用到message 就只会监听message 就是用到几个监听几个 而且是非惰性 会默认调用一次 默认是深度监听 ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 09:48:09 "},"doc/前端/vue/生命周期/生命周期.html":{"url":"doc/前端/vue/生命周期/生命周期.html","title":"生命周期","keywords":"","body":"生命周期 创建 更新 销毁 {{ str }} 修改 import { ref, onBeforeMount, onMounted, onBeforeUpdate, onUpdated, onBeforeUnmount, onUnmounted, onRenderTriggered, onRenderTracked } from 'vue'; let str = ref(\"测试\") let span = ref // 创建 onBeforeMount(() => { console.log('创建之前', span); }) // 创建之后 onMounted(() => { console.log('创建之后', span); }) // 更新之前 onBeforeUpdate(() => { console.log('更新之前', span); }) // 更新之后 onUpdated(() => { console.log('更新之后', span); }) // 销毁之前 onBeforeUnmount(() => { console.log('销毁之前', span); }) // 销毁之后 onUnmounted(() => { console.log('销毁之后', span); }) // 渲染 onRenderTriggered(() => { console.log('onRenderTriggered：'); }) // 跟踪 onRenderTracked(() => { console.log('onRenderTracked：'); }) ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 09:48:09 "},"doc/前端/vue/组件传参/组件传参.html":{"url":"doc/前端/vue/组件传参/组件传参.html","title":"组件传参","keywords":"","body":"组件传参 目录 父组件传值给子组件 子组件 父组件 子组件传值给父组件 子组件 父组件 子组件暴露属性和方法到父组件 子组件 父组件 兄弟组件传参 手写发布订阅模式 mitt 库进行组件之间的传参 main.ts 父组件传值给子组件 两个都不需要导入 defineProps ：接收父组件传过来的参数 withDefaults ：设置默认值， 并且只接收defineProps类型 子组件 // 简单接收父组件传值 // let props = defineProps() // 接收父组件传值 , 并设置默认值 let props = withDefaults(defineProps(), { title: \"默认值1111\", nums: () => [66, 666] }) 父组件 子组件传值给父组件 defineEmits ： 不需要导入， 传值给父组件 子组件 const emit = defineEmits() const send = () => { emit('on-ts-click', \"子传父2\") } 父组件 let getTsName = (name: string) => { sonStr.value = name } 子组件暴露属性和方法到父组件 defineExpose： 暴露属性和方法，注： 这个只有在onMounted 渲染后才生效 子组件 // 暴露属性方法到父组件 defineExpose({ name: \"子组件暴露的属性\", openFuc: () => { console.log('子组件暴露的方法'); } }) 父组件 {{ sonName }} let sonProp = ref>() let sonName = ref(\"默认点击\") let sonOpen: any onMounted(() => { sonName = ref(sonProp.value?.name as string) sonOpen = sonProp.value?.openFuc console.log('sonName=', sonName.value); }) 兄弟组件传参 1. 通过父子组件defineEmits , defineProps 母组件转发 2. 自己手写一个发布订阅模式 3. mitt 库进行组件之间的传参 手写发布订阅模式 type BusClass = { emit: (name: string) => void on: (name: string, callback: Function) => void } type PramsKey = string | number | symbol type List = { [key: PramsKey]: Array } class Bus implements BusClass { list: List constructor() { this.list = {} } on(name: string, callback: Function) { let fn: Array = this.list[name] || [] fn.push(callback) this.list[name] = fn } emit(name: string, ...args: Array) { let evnentName: Array = this.list[name] evnentName.forEach(fn => { fn.apply(this, args) }) } } export default new Bus() mitt 库进行组件之间的传参 导入包： npm install mitt -s main.ts import mitt from 'mitt'; let Mitt = mitt() // 加入vue ,并增加提示类型 declare module 'vue' { export interface ComponentCustomProperties { $Bus: typeof Mitt } } app.config.globalProperties.$Bus = Mitt 1. 传参 import { getCurrentInstance } from 'vue'; let instance = getCurrentInstance() const emitA = () => { instance?.proxy?.$Bus.emit(\"on-click\", \"red\") } 2. 接收参数 import { ref, getCurrentInstance } from 'vue'; let instance = getCurrentInstance() let color = ref(\"green\") instance?.proxy?.$Bus.on(\"on-click\", (c: any) => { color.value = c }) ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 09:48:09 "},"doc/前端/vue/组件/组件.html":{"url":"doc/前端/vue/组件/组件.html","title":"组件","keywords":"","body":"组件 目录 局部组件 全局组件 递归组件 子组件 父组件调用 动态组件component 组件传送 缓存组件keep-alive 缓存实列的生命周期 动画组件transition ， TransitionGroup 和 \\ 的区别# 属性 触发条件 css样式 局部组件 script import Menu from './menu/index.vue' template 全局组件 在main.ts中注册，其他vue页面就可以立即使用 ， 无需引用 import layout from './layout/index.vue' let app=createApp(App) app.component(\"layout\",layout) app.mount('#app') 递归组件 子组件 {{ item.name }} type Props = { data?: T[] | []; } type TreeList = { name: string; icon?: string; children?: TreeList[] | []; } // 接收参数 let props = defineProps>() export default { name: \"index\" } 父组件调用 动态组件component ```vue jsx import { shallowRef } from 'vue' import CompA from './CompA.vue' import CompB from './CompB.vue' const current = shallowRef(CompA) A B ``` # 组件传送 > `Teleport` Vue 3.0新特性之一。 > `Teleport` 是一种能够将我们的模板渲染至指定`DOM`节点，不受父级`style`、`v-show`等属性影响，但`data`、`prop`数据依旧能够共用的技术；类似于 `React` 的 `Portal`。 > 主要解决的问题 因为`Teleport`节点挂载在其他指定的`DOM`节点下，完全不受父级`style`样式影响 ```vue jsx ``` to： 是挂载到哪个dom节点下 disabled： 是否启用 # 缓存组件keep-alive > 有时候我们不希望组件被重新渲染影响使用体验；或者处于性能考虑，避免多次重复渲染降低性能。而是希望组件可以缓存下来,维持当前的状态。这时候就需要用到`keep-alive`组件。 属性 1. include： 缓存包含 2. exclude： 缓存不包含 3. max ： 最大 ```vue jsx import { shallowRef } from 'vue' import CompA from './CompA.vue' import CompB from './CompB.vue' const current = shallowRef(CompA) A B --> --> ## 缓存实列的生命周期 ```vue import { onActivated, onDeactivated } from 'vue' onActivated(() => { // 调用时机为首次挂载 // 以及每次从缓存中被重新插入时 }) onDeactivated(() => { // 在从 DOM 上移除、进入缓存 // 以及组件卸载时调用 }) 动画组件transition ， TransitionGroup 会在一个元素或组件进入和离开 DOM 时应用动画 和 的区别# 支持和 基本相同的 props、CSS 过渡 class 和 JavaScript 钩子监听器，但有以下几点区别： 默认情况下，它不会渲染一个容器元素。但你可以通过传入 tag prop 来指定一个元素作为容器元素来渲染。 过渡模式在这里不可用，因为我们不再是在互斥的元素之间进行切换。 列表中的每个元素都必须有一个独一无二的 key attribute。 CSS 过渡 class 会被应用在列表内的元素上，而不是容器元素上。 属性 duration 控制动画时间 appear 首次加载动画 触发条件 由 v-if 所触发的切换 由 v-show 所触发的切换 由特殊元素 切换的动态组件 css样式 v-enter-from：进入动画的起始状态。在元素插入之前添加，在元素插入完成后的下一帧移除。 v-enter-active：进入动画的生效状态。应用于整个进入动画阶段。在元素被插入之前添加，在过渡或动画完成之后移除。这个 class 可以被用来定义进入动画的持续时间、延迟与速度曲线类型。 v-enter-to：进入动画的结束状态。在元素插入完成后的下一帧被添加 (也就是 v-enter-from 被移除的同时)，在过渡或动画完成之后移除。 v-leave-from：离开动画的起始状态。在离开过渡效果被触发时立即添加，在一帧后被移除。 v-leave-active：离开动画的生效状态。应用于整个离开动画阶段。在离开过渡效果被触发时立即添加，在过渡或动画完成之后移除。这个 class 可以被用来定义离开动画的持续时间、延迟与速度曲线类型。 v-leave-to：离开动画的结束状态。在一个离开动画被触发后的下一帧被添加 (也就是 v-leave-from 被移除的同时)，在过渡或动画完成之后移除。 v-enter-active 和 v-leave-active 给我们提供了为进入和离开动画指定不同速度曲线的能力，我们将在下面的小节中看到一个示例。 切换 --> import { ref } from 'vue'; let flag = ref(true) .box { width: 200px; height: 200px; background-color: green; } /* 进入动画开始 */ .tran-enter-from { width: 0; height: 0; } /* 进入动画生效 */ .tran-enter-active { transition: all 3s ease; } /* 进入动画结束 */ .tran-enter-to { width: 200px; height: 200px; background-color: red; } /* 离开动画开始 */ .tran-leave-from { width: 200px; height: 200px; background-color: green; } /* 离开动画生效 */ .tran-leave-active { transition: all 5s ease; } /* 离开动画结束 */ .tran-leave-to { width: 0; height: 0; } ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 09:48:09 "},"doc/前端/vue/sort插槽/sort插槽.html":{"url":"doc/前端/vue/sort插槽/sort插槽.html","title":"sort插槽","keywords":"","body":"sort插槽 目录 子组件 父组件 插槽就是子组件中的提供给父组件使用的一个占位符，用\\\\ 表示，父组件可以在这个占位符中填充任何模板代码，如 HTML、组件等，填充的内容会替换子组件的\\\\标签。 子组件 父组件 12323 这里是内容 这里是尾部 ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 09:48:09 "},"doc/前端/vue/依赖注入provide inject/依赖注入provide inject.html":{"url":"doc/前端/vue/依赖注入provide inject/依赖注入provide inject.html","title":"依赖注入provide inject","keywords":"","body":"依赖注入provide inject 目录 传递 接收 代码 home A B 父组件向子组件传递数据 传递 provide('key', color) //子组件可以修改 provide('key', readonly(color)) //传递只读 接收 let color = inject\\>('key') //根据传递的key 接收 代码 home 这个是home 红色 绿色 白色 import { ref, provide, readonly } from 'vue' import IndexA from './IndexA.vue' import IndexB from './IndexB.vue' let color = ref(\"red\") provide('color', readonly(color)) .box { height: 200px; width: 100%; background-color: v-bind(color); } A 我是A 修改颜色 import { inject, ref } from 'vue'; import { Ref } from 'vue'; let color = inject>('color') const change = () => { color!.value = \"yellow\" } .box { height: 200px; width: 100%; background-color: v-bind(color); } B 我是B import { inject, ref } from 'vue'; import { Ref } from 'vue'; let color = inject>('color') .box { height: 200px; width: 100%; background-color: v-bind(color); } ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 09:48:09 "},"doc/前端/vue/v-model/v-model.html":{"url":"doc/前端/vue/v-model/v-model.html","title":"v-model","keywords":"","body":"v-model 可以绑定表单， 自定义组件， input , select 在vue3中是破坏性更新的，v-model 其实是一个语法糖由props和emit组合而成的 prop：value -> modelValue； 事件：input -> update:modelValue； v-bind 的 .sync 修饰符和组件的 model 选项已移除 新增 支持多个v-model 新增 支持自定义 修饰符 Modifiers 子组件 关闭 我是v-model子组件 内容： let props = defineProps() // 定义回发事件 // 必须要update:加v-model绑定的name 这样才会绑定到val的ref的对象上 let emit = defineEmits() const close = () => { // 回发 emit(\"update:modelValue\", false) } const change = (e: Event) => { // 回发 let target = e.target as HTMLInputElement let str = props.textValModifiers?.isBt ? target.value + \"变态\" : target.value emit(\"update:textVal\", str) } .model { width: 500px; height: 300px; border: 1px solid #ccc; position: fixed; } 父组件 我是home父组件 flag:{{ flag }} textVal:{{ text }} 开关 import { ref } from 'vue'; import Index from './Index.vue'; let flag = ref(true) let text = ref(\"我是友田\") ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 09:48:09 "},"doc/前端/vue/自定义命令/自定义命令.html":{"url":"doc/前端/vue/自定义命令/自定义命令.html","title":"自定义命令","keywords":"","body":"自定义命令 目录 钩子函数 简单demo 权限实例 必须以 vNameOfDirective 的形式来命名本地自定义指令，以使得它们可以直接在模板中使用 钩子函数 created 元素初始化的时候 beforeMount 指令绑定到元素后调用 只调用一次 mounted 元素插入父级dom调用 beforeUpdate 元素被更新之前调用 updated 元素更新之后 beforeUnmount 在元素被移除前调用 unmounted 指令被移除后调用 只调用一次 简单demo 开关 import { Directive, DirectiveBinding, ref } from 'vue'; import IndexA from './IndexA.vue'; let flag = ref(true) // 定义绑定类型 ，这里是为了 更好的提示 type Dir = { background: string } // v-move-directive 钩子函数 const vMoveDirective: Directive = { // 元素初始化 created: () => { console.log('元素初始化'); }, // 指令绑定到元素后调用，只调用一次 beforeMount: () => { console.log('指令绑定到元素后调用，只调用一次'); }, // 元素插入父级dom调用 mounted: (el: HTMLElement, dir: DirectiveBinding) => { console.log('元素插入父级dom调用'); el.style.backgroundColor = dir.value.background // 获取特性 console.log('特性：aa=', dir.modifiers.aa); console.log('特性：yyt=', dir.modifiers.yyt); }, // 更新之后 updated: () => { console.log('更新的时候'); }, // 在元素被移除前调用 beforeUnmount: (...args: Array) => { console.log(args); console.log(\"=============》 卸载之前\"); console.log('在元素被移除前调用'); }, // 指令被移除后调用，只调用一次 unmounted: (...args: Array) => { console.log(args); console.log(\"=============》 卸载之后\"); console.log('指令被移除后调用，只调用一次'); } } 权限实例 cesh 查看 创建 新增 删除 import type { Directive } from 'vue'; localStorage.setItem(\"userId\", \"xiaoman\") const permissions = [ 'xiaoman:shop:view', 'xiaoman:shop:create', 'xiaoman:shop:edite', 'xiaoman:shop:delete' ] const vHasShow: Directive = (el, bingding) => { let userId = localStorage.getItem(\"userId\") as string if (!permissions.includes(userId + \":shop:\" + bingding.value)) { el.style.display = \"none\" } } .box { button { margin: 20px; } } ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 09:48:09 "},"doc/前端/vue/自定义hook/自定义hook.html":{"url":"doc/前端/vue/自定义hook/自定义hook.html","title":"自定义hook","keywords":"","body":"自定义hook 目录 官方 自定义 其实就是一个函数 官方 import { useAttrs, useSlots } from 'vue'; 自定义 我们引用hooks 时候， 我们需要单个单个引入，index文件他会帮我们自动拼接好 num1: num2: 加法等于:{{ addNum }} 减法等于:{{ subNum }} import { ref } from 'vue'; import useBase64 from '../../Hooks/useBase64'; import useAdd from '../../Hooks/useAdd'; import useSub from '../../Hooks/useSub'; let num1 = ref(2) let num2 = ref(1) let { addNum, addFunc } = useAdd(num1, num2) let { subNum, subFunc } = useSub(num1, num2) addFunc(num1.value, num2.value) subFunc(num1.value, num2.value) useBase64({ el: \"#img\" }).then(res => { console.log('res :>> ', res.baseUrl); }) ts文件 import { ref, watch } from 'vue'; import type { Ref } from 'vue'; const useAdd = (num1: Ref, num2: Ref) => { let addNum = ref(0) watch([num1, num2], ([num1, num2]) => { addFunc(num1, num2) }) const addFunc = (num1: number, num2: number) => { addNum.value = num1 + num2 } return { addNum, addFunc } } export default useAdd ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 09:48:09 "},"doc/前端/vue/UI/UI.html":{"url":"doc/前端/vue/UI/UI.html","title":"UI","keywords":"","body":"UI 目录 Element 安装 完整引入 volar支持 Element 一个 Vue 3 UI 框架 | Element Plus a Vue 3 based component library for designers and developers https://element-plus.gitee.io/zh-CN/ 安装 # npm 安装 npm install element-plus --save 完整引入 // main.ts import { createApp } from 'vue' import ElementPlus from 'element-plus' import 'element-plus/dist/index.css' import App from './App.vue' const app = createApp(App) app.use(ElementPlus) app.mount('#app') volar支持 // tsconfig.json { \"compilerOptions\": { // ... \"types\": [\"element-plus/global\"] } } ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 09:48:09 "},"doc/前端/vue/样式scoped/样式scoped.html":{"url":"doc/前端/vue/样式scoped/样式scoped.html","title":"样式scoped","keywords":"","body":"样式scoped scoped的原理 vue中的scoped 通过在DOM结构以及css样式上加唯一不重复的标记:data-v-hash的方式，以保证唯一（而这个工作是由过PostCSS转译实现的），达到样式私有化模块化的目的。 总结一下scoped三条渲染规则： 给HTML的DOM节点加一个不重复data属性(形如：data-v-123)来表示他的唯一性 在每句css选择器的末尾（编译后的生成的css语句）加一个当前组件的data属性选择器（如[data-v-123]）来私有化样式 如果组件内部包含有其他组件，只会给其他组件的最外层标签加上当前组件的data属性 PostCSS会给一个组件中的所有dom添加了一个独一无二的动态属性data-v-xxxx，然后，给CSS选 Vue 提供了样式穿透:deep() 他的作用就是用来改变 属性选择器的位置 // .dmain[data-v-0330b3b4] .dmain { width: 200px; height: 200px; // .dmain[data-v-0330b3b4] // 样式穿透，可以命中 :deep(input) { background: red; } // 不加样式穿透， 不可以命中 // input { // background: red; // } } ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 09:48:09 "},"doc/前端/vue/unoCss原子化/unoCss原子化.html":{"url":"doc/前端/vue/unoCss原子化/unoCss原子化.html","title":"unoCss原子化","keywords":"","body":"unoCss原子化 ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 09:48:09 "},"doc/前端/项目工程/项目工程.html":{"url":"doc/前端/项目工程/项目工程.html","title":"vue项目工程","keywords":"","body":"项目工程 包含vite 手脚架 ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-11 11:11:23 "},"doc/前端/项目工程/vite/vite.html":{"url":"doc/前端/项目工程/vite/vite.html","title":"vite","keywords":"","body":"vite 目录 使用插件 如何使用 多页面构建 使用环境变量 .env文件 环境变量配置提示 编译打包的时候使用特定的环境变量 前端快速建项目，打包，编译的一个包 // 安装包 npm init vite@latest // 使用vite建立项目 npm init vite@latest // 运行命令 npm run xx // 打包 vite build 使用插件 插件列表地址 Vite Rollup Plugins A list of rollup plugins compatibility for Vite https://vite-rollup-plugins.patak.dev/ 如何使用 若要使用一个插件，需要将它添加到项目的 devDependencies 并在 vite.config.js 配置文件中的 plugins 数组中引入它。例如，要想为传统浏览器提供支持，可以按下面这样使用官方插件 @vitejs/plugin-legacy： // 安装插件 npm i -D @vitejs/plugin-legacy // 配置vite.config.js 文件 // vite.config.js import image from '@rollup/plugin-image' import legacy from '@vitejs/plugin-legacy' import { defineConfig } from 'vite' export default defineConfig({ plugins: [ legacy({ targets: ['defaults', 'not IE 11'] }), { ...image(), // 强制顺序， pre在vite 核心插件之前 // post 在vite核心插件之后（默认） enforce: 'pre', // 指定调用环境， 默认是开发和生成都调用 // build（生产） ,server（开发） apply: 'build', } ] }) 多页面构建 // 文件路径 ├── package.json ├── vite.config.js ├── index.html ├── main.js └── nested ├── index.html └── nested.js // vite.config.js const { resolve } = require('path') const { defineConfig } = require('vite') module.exports = defineConfig({ build: { rollupOptions: { input: { main: resolve(__dirname, 'index.html'), nested: resolve(__dirname, 'nested/index.html') } } } }) 使用环境变量 Vite 在一个特殊的 import.meta.env 对象上暴露环境变量。这里有一些在所有情况下都可以使用的内建变量： import.meta.env.MODE: {string} 应用运行的模式。 import.meta.env.BASE_URL: {string} 部署应用时的基本 URL。他由base 配置项决定。 import.meta.env.PROD: {boolean} 应用是否运行在生产环境。 import.meta.env.DEV: {boolean} 应用是否运行在开发环境 (永远与 import.meta.env.PROD相反)。 .env文件 一般就在src目录下 .env # 所有情况下都会加载 .env.local # 所有情况下都会加载，但会被 git 忽略 .env.[mode] # 只在指定模式下加载 .env.[mode].local # 只在指定模式下加载，但会被 git 忽略 在生产环境中，这些环境变量会在构建时被静态替换，因此，在引用它们时请使用完全静态的字符串。动态的 key 将无法生效。import.meta.env[key] 是无效的。 注意： 只有以 VITE_ 为前缀的变量才会暴露给经过 vite 处理的代码 // 这个不会暴露出去 DB_PASSWORD=foobar // 这个会暴露 VITE_APP_TITLE=123 // 获取环境配置 import.meta.env.VITE_APP_TITLE 环境变量配置提示 src 目录下创建一个 env.d.ts 文件 /// interface ImportMetaEnv { readonly VITE_APP_TITLE: string // 更多环境变量... } interface ImportMeta { readonly env: ImportMetaEnv } 注意： 这里我使用webstom 有时候配置了这个没有提示出来， 那我们需要配置下ts的配置改成vue语言服务器volar 编译打包的时候使用特定的环境变量 //package.json 配置文件 { \"name\": \"vue\", \"private\": true, \"version\": \"0.0.0\", \"type\": \"module\", \"scripts\": { // 在命令后面加上--mode 加上环境名称 \"dev\": \"vite --mode dev\", \"build\": \"vue-tsc && vite build --mode build\", \"preview\": \"vite preview\" }, \"dependencies\": { \"element-plus\": \"^2.4.2\", \"vue\": \"^3.3.4\" }, \"devDependencies\": { \"@vitejs/plugin-vue\": \"^4.2.3\", \"typescript\": \"^5.0.2\", \"unplugin-auto-import\": \"^0.16.7\", \"unplugin-vue-components\": \"^0.25.2\", \"vite\": \"^4.4.5\", \"vue-tsc\": \"^1.8.5\" } } ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 09:48:09 "},"doc/前端/项目工程/vue router/vue router.html":{"url":"doc/前端/项目工程/vue router/vue router.html","title":"vue router","keywords":"","body":"vue router 目录 安装 Vue Router 是 Vue.js 的官方路由。它与 Vue.js 核心深度集成，让用 Vue.js 构建单页应用变得轻而易举。功能包括： 嵌套路由映射 动态路由选择 模块化、基于组件的路由配置 路由参数、查询、通配符 展示由 Vue.js 的过渡系统提供的过渡效果 细致的导航控制 自动激活 CSS 类的链接 HTML5 history 模式或 hash 模式 可定制的滚动行为 URL 的正确编码 安装 npm install vue-router@4 创建router文件夹 // index.ts import {createRouter, createWebHashHistory, RouteRecordRaw} from 'vue-router' const test = () => import('@/pages/test.vue') // 2. 定义一些路由 // 每个路由都需要映射到一个组件。 const routes: Array = [ { path: '/login', name: 'login', meta: { title: '登录', hidden: true, }, component: test, }, { path: '/', component: test, meta: { title: '首页', }, children: [ { path: '', name: 'home', meta: { title: '首页', icon: 'homepage', }, component: test, }, ], }, ] // 3. 创建路由实例并传递 `routes` 配置 // 你可以在这里输入更多的配置，但我们在这里 const router = createRouter({ // 4. 内部提供了 history 模式的实现。为了简单起见，我们在这里使用 hash 模式。 history: createWebHashHistory(), routes: routes, }) // 使用TS扩展 declare module 'vue-router' { interface RouteMeta { title: string; hidden?: boolean; } } // 导出router export default router 全局守卫 // permission.ts import router from \"@/router/index.ts\"; // 全局前置守卫 router.beforeEach(async (to, from) => { console.log(to, from) }); // 全局后置钩子 router.afterEach((to, from) => { // finish progress bar console.log(to, from) }); ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 09:48:09 "},"doc/前端/项目工程/css reset/css reset.html":{"url":"doc/前端/项目工程/css reset/css reset.html","title":"css reset","keywords":"","body":"css reset meyerweb.com The web home of Eric A. Meyer, CSS guy; and his wife Kathryn, doctor of nursing. https://meyerweb.com/eric/tools/css/reset/ css 初始样式清理 /* http://meyerweb.com/eric/tools/css/reset/ v2.0 | 20110126 License: none (public domain) */ html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video { margin: 0; padding: 0; border: 0; font-size: 100%; font: inherit; vertical-align: baseline; } /* HTML5 display-role reset for older browsers */ article, aside, details, figcaption, figure, footer, header, hgroup, menu, nav, section { display: block; } body { line-height: 1; } ol, ul { list-style: none; } blockquote, q { quotes: none; } blockquote:before, blockquote:after, q:before, q:after { content: ''; content: none; } table { border-collapse: collapse; border-spacing: 0; } ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 09:48:09 "},"doc/前端/项目工程/vite @ 别名/vite @ 别名.html":{"url":"doc/前端/项目工程/vite @ 别名/vite @ 别名.html","title":"vite @ 别名","keywords":"","body":"vite @ 别名 // 先按照node包 npm i @types/node // vite.config.ts import {resolve} from 'node:path' export default defineConfig({ // 设置别名 resolve: { alias: { \"@\": resolve(__dirname, \"./src\"), \"@layout\": resolve(__dirname, \"./src/layout\"), } } }) // tsconfig.json配置 // { // \"compilerOptions\": { // ///... // // 配置别名 // \"baseUrl\": \".\", // \"paths\": { // \"@/*\": [ // \"src/*\" // ], // \"@layout/*\": [ // \"src/layout/*\" // ] // } // } // } ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 09:48:09 "},"doc/前端/项目工程/自动引入组件/自动引入组件.html":{"url":"doc/前端/项目工程/自动引入组件/自动引入组件.html","title":"自动引入组件","keywords":"","body":"自动引入组件 // 安装 npm install -D unplugin-vue-components unplugin-auto-import // vite.config.ts import { defineConfig } from 'vite' import AutoImport from 'unplugin-auto-import/vite' import Components from 'unplugin-vue-components/vite' import { ElementPlusResolver } from 'unplugin-vue-components/resolvers' export default defineConfig({ // ... plugins: [ // ... AutoImport({ imports: ['vue', 'vue-router', 'pinia'], resolvers: [], }), Components({ resolvers: [], }), ], }) ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 09:48:09 "},"doc/前端/项目工程/pinia/pinia.html":{"url":"doc/前端/项目工程/pinia/pinia.html","title":"pinia","keywords":"","body":"pinia 目录 安装 初步使用 修改里面的值 解构 调用异步方法 pinia 持久化 全部实例 前言 全局状态管理工具 Pinia.js 有如下特点： 完整的 ts 的支持； 足够轻量，压缩后的体积只有1kb左右; 去除 mutations，只有 state，getters，actions； actions 支持同步和异步； 代码扁平化没有模块嵌套，只有 store 的概念，store 之间可以自由使用，每一个store都是独立的 无需手动添加 store，store 一旦创建便会自动添加； 支持Vue3 和 Vue2 Pinia 🍍 Intuitive, type safe, light and flexible Store for Vue https://pinia.vuejs.org/ 安装 npm install pinia npm i pinia-plugin-persistedstate # main.ts import { createPinia } from 'pinia'; import persist from 'pinia-plugin-persistedstate' // 引用pinia let pinia = createPinia() pinia.use(persist) app.use(pinia) 初步使用 //store-nameSpace export const enum Names { test = 'test' } // ts import { useTestStore } from '../../store/test'; // 使用pinia const test = useTestStore() //temp pinia :{{ test.curren }}名称：{{ test.name }} //store ts import { defineStore } from 'pinia'; import { Names } from './store-nameSpace'; export const useTestStore = defineStore(Names.test, { // 初始化值 state: () => { return { curren: 100, name: \"小满\" } }, // 格式化： 类似于computed getters: { }, //类似于methods 可以操作异步，同步提交 actions: { setCurren() { this.curren++ }, setName(n: string) { this.name = n } } }) 修改里面的值 // 修改pinia // 1.test.curren++ // 2.test.$patch({ curren: 88, name: \"Ceshi\" }) // 3.test.$patch((state) => { state.curren = state.curren + 1 state.name = 'ceshi' }) // 4.全部替换 test.$state = { curren: 1, name: 'ces' } // 5.test.setCurren() ,test.setName(\"测试\") 解构 //ts import { storeToRefs } from 'pinia'; // pinia 解构是不具有响应式 // const { curren, name } = test // 需要包裹一层storeToRefs const { curren, name } = storeToRefs(test) 调用异步方法 //store ts actions async setInit() { this.user = await Login() }, const Login = (): Promise => { return new Promise((resolve) => { setTimeout(() => { resolve({ name: \"飞机\", age: 18 }) }, 2000) }) } pinia 持久化 //main.ts import { createPinia } from 'pinia' import persist from 'pinia-plugin-persistedstate' let pinia = createPinia() pinia.use(persist) app.use(pinia) // store export const useTestStore = defineStore(Names.test, { // 初始化值 state: () => { return { name: \"小满\" } }, persist:true, //类似于methods 可以操作异步，同步提交 actions: { async setInit() { this.user = await Login() }, } }) 全部实例 store ts //store ts import { defineStore } from 'pinia'; import { Names } from './store-nameSpace'; type user = { name: string age: number } const Login = (): Promise => { return new Promise((resolve) => { setTimeout(() => { resolve({ name: \"飞机\", age: 18 }) }, 2000) }) } export const useTestStore = defineStore(Names.test, { // 初始化值 state: () => { return { user: {}, curren: 100, name: \"小满\" } }, // 格式化： 类似于computed getters: { getUser(): string { let age = this.getAge return `名称=${this.user.name},年龄=${age}` }, getAge(): number { return this.user.age } }, //类似于methods 可以操作异步，同步提交 actions: { async setInit() { this.user = await Login() }, setCurren() { this.curren++ }, setName(n: string) { this.name = n } } }) home.vue pinia :{{ test.curren }}名称：{{ test.name }} 解构 :{{ curren }}名称：{{ name }} change asyncInit 异步:{{ test.user }} 格式化:{{ test.getUser }} import { useTestStore } from '../../store/test'; import { storeToRefs } from 'pinia'; // 使用pinia const test = useTestStore() // pinia 解构是不具有响应式 // const { curren, name } = test // 需要包裹一层storeToRefs const { curren, name } = storeToRefs(test) console.log('test=======>', test); // 修改pinia // 1.test.curren++ // 2.test.$patch({ curren: 88, name: \"Ceshi\" }) // 3.test.$patch((state) => { state.curren = state.curren + 1 state.name = 'ceshi' }) // 4.全部替换 test.$state = { curren: 1, name: 'ces' } // 5.test.setCurren() ,test.setName(\"测试\") const change = () => { test.setCurren() test.setName(\"测试\") } const asyncInit = () => { test.setInit() } ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 09:48:09 "},"doc/前端/项目工程/vue 环境配置/vue 环境配置.html":{"url":"doc/前端/项目工程/vue 环境配置/vue 环境配置.html","title":"vue 环境配置","keywords":"","body":"vue 环境配置 目录 vscode 加入提示 使用 编译后使用模式 Vite Next Generation Frontend Tooling https://cn.vitejs.dev/guide/env-and-mode.html .env.development ：开发 .env.production ：正式 .env.test :测试 文件配置 .env.production # 模式 VITE_APP_ENV='production' # base api VITE_APP_API_BASE='/api' vscode 加入提示 //src 目录下创建文件vite-env.d.ts /// interface ImportMetaEnv { readonly VITE_APP_API_BASE: string // 更多环境变量... } 使用 //直接在 代码中这样使用 import.meta.env.VITE_APP_API_BASE 编译后使用模式 默认情况下，开发服务器 (dev 命令) 运行在 development (开发) 模式，而 build 命令则运行在 production (生产) 模式。 在某些情况下，若想在 vite build 时运行不同的模式来渲染不同的标题，你可以通过传递 --mode 选项标志来覆盖命令使用的默认模式。例如，如果你想在 staging （预发布）模式下构建应用： vite build --mode staging ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 09:48:09 "},"doc/前端/项目工程/axios/axios.html":{"url":"doc/前端/项目工程/axios/axios.html","title":"axios","keywords":"","body":"axios 起步 | Axios 中文文档 | Axios 中文网 https://www.axios-http.cn/docs/intro 安装： npm install axios // src/http/index.ts import axios from 'axios' import {decodeErrorCode, decodeErrorStatus} from \"./tool.ts\"; // 创建axios实列 const instance = axios.create({ baseURL: import.meta.env.VITE_APP_HTTP + import.meta.env.VITE_APP_HTTP_PREFIX, // 域名配置 timeout: 1000 * 5, //超时配置 responseType: 'json', withCredentials: true, }) // 添加请求拦截器 // 开始请求时，之前的操作 instance.interceptors.request.use(function (config) { // 判断是否登录 return config }, function (error) { // 对请求错误做些什么 return Promise.reject(error) }) // 添加响应拦截器 instance.interceptors.response.use(function (response) { // 判断是否登录 let {status, data} = response if (status == 200) { return data } return data }, function (error) { let message = '' let {code, response} = error // 判断有无返回体 if (response) { const {status} = response if (status === 401) { // 跳回登录 return } message = decodeErrorStatus(status) } else { message = decodeErrorCode(code) } if (message === \"\") { return Promise.reject(error) } else { return Promise.reject(new Error(message)) } }) export default instance // src/http/tool.ts const ERR_FR_TOO_MANY_REDIRECTS = \"ERR_FR_TOO_MANY_REDIRECTS\"; const ERR_BAD_OPTION_VALUE = \"ERR_BAD_OPTION_VALUE\"; const ERR_BAD_OPTION = \"ERR_BAD_OPTION\"; const ERR_NETWORK = \"ERR_NETWORK\"; const ERR_DEPRECATED = \"ERR_DEPRECATED\"; const ERR_BAD_RESPONSE = \"ERR_BAD_RESPONSE\"; const ERR_BAD_REQUEST = \"ERR_BAD_REQUEST\"; const ERR_NOT_SUPPORT = \"ERR_NOT_SUPPORT\"; const ERR_INVALID_URL = \"ERR_INVALID_URL\"; const ERR_CANCELED = \"ERR_CANCELED\"; const ECONNABORTED = \"ECONNABORTED\"; const ETIMEDOUT = \"ETIMEDOUT\"; export const decodeErrorCode = (code: string) => { let message = \"\" switch (code) { case ERR_FR_TOO_MANY_REDIRECTS: message = '过多的重定向' break case ERR_BAD_OPTION_VALUE: message = '错误选项值' break case ERR_BAD_OPTION: message = '错误选项' break case ERR_NETWORK: message = '连接失败' break case ERR_DEPRECATED: message = \"弃用\" break case ERR_BAD_RESPONSE: message = '错误的返回结果' break case ERR_BAD_REQUEST: message = '错误的请求' break case ERR_NOT_SUPPORT: message = '不支持' break case ERR_INVALID_URL: message = '无效的url' break case ERR_CANCELED: message = '取消' break case ECONNABORTED: message = '远程主机拒绝网络服务' break case ETIMEDOUT: message = '结束' break default: message = code } return message } export const decodeErrorStatus = (status: number) => { let message = \"\" switch (status) { case 302: message = '接口重定向了！' break case 400: message = '参数不正确！' break case 401: message = '您未登录，或者登录已经超时，请先登录！' break case 403: message = '您没有权限操作！' break case 404: message = `请求地址出错` break case 408: message = '请求超时！' break case 409: message = '系统已存在相同数据！' break case 500: message = '服务器内部错误！' break case 501: message = '服务未实现！' break case 502: message = '网关错误！' break case 503: message = '服务不可用！' break case 504: message = '服务暂时无法访问，请稍后再试！' break case 505: message = 'HTTP 版本不受支持！' break default: message = \"\" break } return message } ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 09:48:09 "},"doc/前端/项目工程/定义全局变量和函数/定义全局变量和函数.html":{"url":"doc/前端/项目工程/定义全局变量和函数/定义全局变量和函数.html","title":"定义全局变量和函数","keywords":"","body":"定义全局变量和函数 在main.ts 中app.config.globalProperties中定义，其他vue文件使用不需要导入直接使用 main.ts // 定义全局变量并增加提示类型 declare module 'vue' { export interface ComponentCustomProperties { $Bus: typeof Mitt $Env: string $Filter: Filter } } // 定义全局变量 app.config.globalProperties.$Bus = Mitt app.config.globalProperties.$Env = \"dev\" type Filter = { format(str: T): string } // 定义全局函数 app.config.globalProperties.$Filter = { format(str: T) { return `yyt-${str}` } } 其他vue文件使用 $Env: {{ $Env }} env: {{ env }} $Filter: {{ $Filter.format('友田') }} Filter: {{ filter?.format('友田') }} import { getCurrentInstance, ref } from 'vue'; import type { Ref } from 'vue'; // 得到当前实例 let app = getCurrentInstance() let env: Ref = ref(app?.proxy?.$Env as string) let filter = app?.proxy?.$Filter console.log('filterFormat====>', filter); ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 09:48:09 "},"doc/前端/项目工程/mock/mock.html":{"url":"doc/前端/项目工程/mock/mock.html","title":"mock","keywords":"","body":"mock npm i -d mockjs npm install --save-dev @types/mockjs // src/mock/index.ts import Mock, {Random} from 'mockjs' let baseUrl = import.meta.env.VITE_APP_HTTP + import.meta.env.VITE_APP_HTTP_PREFIX // 这里一定要加上监听的地址和端口 Mock.mock(baseUrl + '/ping', \"get\", { code: 200, 'data|1-10': [ { \"id|+1\": 1, \"name\": Random.name(), } ] }) // src/main.ts import \"@/mock\" ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 09:48:09 "},"doc/前端/项目工程/tailwindcss/tailwindcss.html":{"url":"doc/前端/项目工程/tailwindcss/tailwindcss.html","title":"tailwindcss","keywords":"","body":"tailwindcss ```bash title=\"安装\" npm install -D tailwindcss@3.4.17 postcss autoprefixer npx tailwindcss init -p ```bash title=\"tailwind.config.js\" /** @type {import('tailwindcss').Config} */ export default { content: [ \"./index.html\", \"./src/**/*.{vue,js,ts,jsx,tsx}\", ], theme: { extend: {}, }, plugins: [], } bash title=\"style.css\" @tailwind base; @tailwind components; @tailwind utilities; ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 09:48:09 "},"doc/前端/项目工程/svg/svg.html":{"url":"doc/前端/项目工程/svg/svg.html","title":"svg","keywords":"","body":"svg ```bash title=\"安装\" npm i vite-plugin-svg-icons -D ```vue title=\"vite.config.ts\" import {createSvgIconsPlugin} from \"vite-plugin-svg-icons\"; import path from 'path'; export default defineConfig({ plugins: [ ..., createSvgIconsPlugin({ // 指定需要缓存的图标文件夹 iconDirs: [path.resolve(process.cwd(), 'src/icons/svg')], // 指定symbolId格式 symbolId: '[name]', }), ] }) ```vue title=\"src/main.ts\" import 'virtual:svg-icons-register' ```vue title=\"src/components/SvgIcon.vue\" import {computed} from 'vue'; const props = withDefaults( defineProps(), { width: 20, height: 20, color: '#000000', } ) // 获取svg图标名称，需要和vite.config.ts中的配置保持一致 const iconName = computed(() => `#${props.iconName}`); ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 09:48:09 "},"doc/前端/element/element.html":{"url":"doc/前端/element/element.html","title":"vue element","keywords":"","body":"element element 框架的一些使用建议 ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-11 11:11:54 "},"doc/前端/element/el-popover 点击其他区域关闭弹出框/el-popover 点击其他区域关闭弹出框.html":{"url":"doc/前端/element/el-popover 点击其他区域关闭弹出框/el-popover 点击其他区域关闭弹出框.html","title":"el-popover 点击其他区域关闭弹出框","keywords":"","body":"el-popover 点击其他区域关闭弹出框 点击其他区域关闭弹出框 多个弹出框的时候, 关闭其他弹出框 ```vue title=\"const refs = ref([]); // 使用回调的方式收集 const setRefs = (el: any) => { refs.value.push(el); }; // 更新时-重置refs onBeforeUpdate(() => { refs.value = []; }); // 关闭 const handleClose = () => refs.value.forEach(v => v.hide());\" const refs = ref([]); // 使用回调的方式收集 const setRefs = (el: any) => { refs.value.push(el); }; // 更新时-重置refs onBeforeUpdate(() => { refs.value = []; }); // 关闭 const handleClose = () => refs.value.forEach(v => v.hide()); ``` ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 09:48:08 "},"doc/前端/element/el-table宽度无法自适应/el-table宽度无法自适应.html":{"url":"doc/前端/element/el-table宽度无法自适应/el-table宽度无法自适应.html","title":"el-table宽度无法自适应","keywords":"","body":"el-table宽度无法自适应 当我父级div 使用flex布局的时候, 表格扩大宽大可以自适应, 但是当表格缩小的时候自适应不了 使用grid 来使表格自适应宽度,在table 上加个父级div , 打上grid 给flex顶掉这样就可以了 ©2025 瑾语 all right reserved，powered by Gitbook该文档修订时间： 2025-04-07 09:48:08 "}}